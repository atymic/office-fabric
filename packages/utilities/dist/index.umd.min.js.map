{"version":3,"file":"index.umd.min.js","sources":["../src/dom/getDocument.ts","../src/dom/getWindow.ts","../src/dom/setSSR.ts","../src/Async.ts","../src/dom/getParent.ts","../src/dom/getVirtualParent.ts","../src/dom/isVirtualElement.ts","../src/dom/elementContainsAttribute.ts","../src/dom/findElementRecursive.ts","../src/focus.ts","../../../node_modules/tslib/tslib.es6.js","../../../node_modules/@uifabric/merge-styles/lib/Stylesheet.js","../../../node_modules/@uifabric/merge-styles/lib/extractStyleParts.js","../../../node_modules/@uifabric/merge-styles/lib/StyleOptionsState.js","../../../node_modules/@uifabric/merge-styles/lib/transforms/kebabRules.js","../../../node_modules/@uifabric/merge-styles/lib/getVendorSettings.js","../../../node_modules/@uifabric/merge-styles/lib/transforms/prefixRules.js","../../../node_modules/@uifabric/merge-styles/lib/transforms/provideUnits.js","../../../node_modules/@uifabric/merge-styles/lib/transforms/rtlifyRules.js","../../../node_modules/@uifabric/merge-styles/lib/styleToClassName.js","../../../node_modules/@uifabric/merge-styles/lib/mergeStyleSets.js","../../../node_modules/@uifabric/merge-styles/lib/concatStyleSets.js","../../../node_modules/@uifabric/set-version/lib/setVersion.js","../../../node_modules/@uifabric/set-version/lib/index.js","../../../node_modules/@uifabric/merge-styles/lib/version.js","../src/KeyCodes.ts","../src/rtl.ts","../src/sessionStorage.ts","../src/classNamesFunction.ts","../src/GlobalSettings.ts","../src/customizations/Customizations.ts","../src/customizations/mergeSettings.ts","../src/array.ts","../src/keyboard.ts","../src/initializeFocusRects.ts","../src/memoize.ts","../src/merge.ts","../src/getId.ts","../src/object.ts","../src/properties.ts","../src/initials.ts","../src/language.ts","../src/scroll.ts","../src/EventGroup.ts","../../../node_modules/@uifabric/merge-styles/lib/mergeStyles.js","../src/positioning/positioning.types.ts","../src/Rectangle.ts","../src/warn/warn.ts","../src/css.ts","../src/dom/elementContains.ts","../src/localStorage.ts","../src/ie11Detector.ts","../src/dom/on.ts","../src/warn/warnConditionallyRequiredProps.ts","../src/warn/warnControlledUsage.ts","../src/warn/warnDeprecations.ts","../src/warn/warnMutuallyExclusive.ts"],"sourcesContent":["import { _isSSR } from './setSSR'\r\n\r\n/**\r\n * Helper to get the document object. Note that in popup window cases, document\r\n * might be the wrong document, which is why we look at ownerDocument for the\r\n * truth. Also note that the SSR flag is used to test ssr scenarios even if\r\n * document is defined (from JSDOM for example.)\r\n *\r\n * @public\r\n */\r\nexport function getDocument (rootElement?: HTMLElement | null): Document | undefined {\r\n  if (_isSSR || typeof document === 'undefined') {\r\n    return undefined\r\n  } else {\r\n    const el = rootElement as Element\r\n\r\n    return el && el.ownerDocument ? el.ownerDocument : document\r\n  }\r\n}\r\n","import { _isSSR } from './setSSR'\r\n\r\nlet _window: Window | undefined\r\n\r\n// Note: Accessing \"window\" in IE11 is somewhat expensive, and calling \"typeof window\"\r\n// hits a memory leak, whereas aliasing it and calling \"typeof _window\" does not.\r\n// Caching the window value at the file scope lets us minimize the impact.\r\ntry {\r\n  _window = window\r\n} catch (e) {\r\n  /* no-op */\r\n}\r\n\r\n/**\r\n * Helper to get the window object. The helper will make sure to use a cached variable\r\n * of \"window\", to avoid overhead and memory leaks in IE11. Note that in popup scenarios the\r\n * window object won't match the \"global\" window object, and for these scenarios, you should\r\n * pass in an element hosted within the popup.\r\n *\r\n * @public\r\n */\r\nexport function getWindow (rootElement?: Element | null): Window | undefined {\r\n  if (_isSSR || typeof _window === 'undefined') {\r\n    return undefined\r\n  } else {\r\n    const el = rootElement as Element\r\n\r\n    return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window\r\n  }\r\n}\r\n","export let _isSSR = false\r\n\r\n/**\r\n * Helper to set ssr mode to simulate no window object returned from getWindow helper.\r\n *\r\n * @public\r\n */\r\nexport function setSSR (isEnabled: boolean): void {\r\n  _isSSR = isEnabled\r\n}\r\n","import { getWindow } from './dom/getWindow'\r\n\r\ndeclare function setTimeout(cb: Function, delay: number): number;\r\ndeclare function setInterval(cb: Function, delay: number): number;\r\n\r\n/**\r\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\r\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\r\n *\r\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\r\n * new instance of the class and remember to call dispose() during your code's dispose handler.\r\n *\r\n * @public\r\n */\r\nexport class Async {\r\n  private _timeoutIds: { [id: number]: boolean } | null = null;\r\n  private _immediateIds: { [id: number]: boolean } | null = null;\r\n  private _intervalIds: { [id: number]: boolean } | null = null;\r\n  private _animationFrameIds: { [id: number]: boolean } | null = null;\r\n  private _isDisposed: boolean;\r\n  private _parent: object | null;\r\n  // tslint:disable-next-line:no-any\r\n  private _onErrorHandler: ((e: any) => void) | undefined;\r\n  private _noop: () => void;\r\n  // tslint:disable-next-line:no-any\r\n  constructor (parent?: object, onError?: (e: any) => void) {\r\n    this._isDisposed = false\r\n    this._parent = parent || null\r\n    this._onErrorHandler = onError\r\n    this._noop = () => {\r\n      /* do nothing */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispose function, clears all async operations.\r\n   */\r\n  public dispose (): void {\r\n    let id\r\n\r\n    this._isDisposed = true\r\n    this._parent = null\r\n\r\n    // Clear timeouts.\r\n    if (this._timeoutIds) {\r\n      for (id in this._timeoutIds) {\r\n        if (this._timeoutIds.hasOwnProperty(id)) {\r\n          this.clearTimeout(parseInt(id, 10))\r\n        }\r\n      }\r\n\r\n      this._timeoutIds = null\r\n    }\r\n\r\n    // Clear immediates.\r\n    if (this._immediateIds) {\r\n      for (id in this._immediateIds) {\r\n        if (this._immediateIds.hasOwnProperty(id)) {\r\n          this.clearImmediate(parseInt(id, 10))\r\n        }\r\n      }\r\n\r\n      this._immediateIds = null\r\n    }\r\n\r\n    // Clear intervals.\r\n    if (this._intervalIds) {\r\n      for (id in this._intervalIds) {\r\n        if (this._intervalIds.hasOwnProperty(id)) {\r\n          this.clearInterval(parseInt(id, 10))\r\n        }\r\n      }\r\n      this._intervalIds = null\r\n    }\r\n\r\n    // Clear animation frames.\r\n    if (this._animationFrameIds) {\r\n      for (id in this._animationFrameIds) {\r\n        if (this._animationFrameIds.hasOwnProperty(id)) {\r\n          this.cancelAnimationFrame(parseInt(id, 10))\r\n        }\r\n      }\r\n\r\n      this._animationFrameIds = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SetTimeout override, which will auto cancel the timeout during dispose.\r\n   * @param callback - Callback to execute.\r\n   * @param duration - Duration in milliseconds.\r\n   * @returns The setTimeout id.\r\n   */\r\n  public setTimeout (callback: () => void, duration: number): number {\r\n    let timeoutId = 0\r\n\r\n    if (!this._isDisposed) {\r\n      if (!this._timeoutIds) {\r\n        this._timeoutIds = {}\r\n      }\r\n\r\n      /* tslint:disable:ban-native-functions */\r\n      timeoutId = setTimeout(() => {\r\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\r\n\r\n        try {\r\n          // Now delete the record and call the callback.\r\n          if (this._timeoutIds) {\r\n            delete this._timeoutIds[timeoutId]\r\n          }\r\n          callback.apply(this._parent)\r\n        } catch (e) {\r\n          if (this._onErrorHandler) {\r\n            this._onErrorHandler(e)\r\n          }\r\n        }\r\n      }, duration)\r\n      /* tslint:enable:ban-native-functions */\r\n\r\n      this._timeoutIds[timeoutId] = true\r\n    }\r\n\r\n    return timeoutId\r\n  }\r\n\r\n  /**\r\n   * Clears the timeout.\r\n   * @param id - Id to cancel.\r\n   */\r\n  public clearTimeout (id: number): void {\r\n    if (this._timeoutIds && this._timeoutIds[id]) {\r\n      /* tslint:disable:ban-native-functions */\r\n      clearTimeout(id)\r\n      delete this._timeoutIds[id]\r\n      /* tslint:enable:ban-native-functions */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SetImmediate override, which will auto cancel the immediate during dispose.\r\n   * @param callback - Callback to execute.\r\n   * @param targetElement - Optional target element to use for identifying the correct window.\r\n   * @returns The setTimeout id.\r\n   */\r\n  public setImmediate (callback: () => void, targetElement?: Element | null): number {\r\n    let immediateId = 0\r\n    const win = getWindow(targetElement)!\r\n\r\n    if (!this._isDisposed) {\r\n      if (!this._immediateIds) {\r\n        this._immediateIds = {}\r\n      }\r\n\r\n      /* tslint:disable:ban-native-functions */\r\n      let setImmediateCallback = () => {\r\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\r\n\r\n        try {\r\n          // Now delete the record and call the callback.\r\n          if (this._immediateIds) {\r\n            delete this._immediateIds[immediateId]\r\n          }\r\n          callback.apply(this._parent)\r\n        } catch (e) {\r\n          this._logError(e)\r\n        }\r\n      }\r\n\r\n      immediateId = win.setTimeout(setImmediateCallback, 0)\r\n      /* tslint:enable:ban-native-functions */\r\n\r\n      this._immediateIds[immediateId] = true\r\n    }\r\n\r\n    return immediateId\r\n  }\r\n\r\n  /**\r\n   * Clears the immediate.\r\n   * @param id - Id to cancel.\r\n   * @param targetElement - Optional target element to use for identifying the correct window.\r\n   */\r\n  public clearImmediate (id: number, targetElement?: Element | null): void {\r\n    const win = getWindow(targetElement)!\r\n\r\n    if (this._immediateIds && this._immediateIds[id]) {\r\n      /* tslint:disable:ban-native-functions */\r\n      win.clearTimeout(id)\r\n      delete this._immediateIds[id]\r\n      /* tslint:enable:ban-native-functions */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SetInterval override, which will auto cancel the timeout during dispose.\r\n   * @param callback - Callback to execute.\r\n   * @param duration - Duration in milliseconds.\r\n   * @returns The setTimeout id.\r\n   */\r\n  public setInterval (callback: () => void, duration: number): number {\r\n    let intervalId = 0\r\n\r\n    if (!this._isDisposed) {\r\n      if (!this._intervalIds) {\r\n        this._intervalIds = {}\r\n      }\r\n\r\n      /* tslint:disable:ban-native-functions */\r\n      intervalId = setInterval(() => {\r\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\r\n        try {\r\n          callback.apply(this._parent)\r\n        } catch (e) {\r\n          this._logError(e)\r\n        }\r\n      }, duration)\r\n      /* tslint:enable:ban-native-functions */\r\n\r\n      this._intervalIds[intervalId] = true\r\n    }\r\n\r\n    return intervalId\r\n  }\r\n\r\n  /**\r\n   * Clears the interval.\r\n   * @param id - Id to cancel.\r\n   */\r\n  public clearInterval (id: number): void {\r\n    if (this._intervalIds && this._intervalIds[id]) {\r\n      /* tslint:disable:ban-native-functions */\r\n      clearInterval(id)\r\n      delete this._intervalIds[id]\r\n      /* tslint:enable:ban-native-functions */\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a function that, when executed, will only call the func function at most once per\r\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\r\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\r\n   * function will return the result of the last func call.\r\n   *\r\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\r\n   *\r\n   * @param func - The function to throttle.\r\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\r\n   * @param options - The options object.\r\n   * @returns The new throttled function.\r\n   */\r\n  public throttle<T extends Function> (\r\n    func: T,\r\n    wait?: number,\r\n    options?: {\r\n      leading?: boolean;\r\n      trailing?: boolean;\r\n    }\r\n  ): T | (() => void) {\r\n    if (this._isDisposed) {\r\n      return this._noop\r\n    }\r\n\r\n    let waitMS = wait || 0\r\n    let leading = true\r\n    let trailing = true\r\n    let lastExecuteTime = 0\r\n    let lastResult: T\r\n    // tslint:disable-next-line:no-any\r\n    let lastArgs: any[]\r\n    let timeoutId: number | null = null\r\n\r\n    if (options && typeof options.leading === 'boolean') {\r\n      leading = options.leading\r\n    }\r\n\r\n    if (options && typeof options.trailing === 'boolean') {\r\n      trailing = options.trailing\r\n    }\r\n\r\n    let callback = (userCall?: boolean) => {\r\n      let now = new Date().getTime()\r\n      let delta = now - lastExecuteTime\r\n      let waitLength = leading ? waitMS - delta : waitMS\r\n      if (delta >= waitMS && (!userCall || leading)) {\r\n        lastExecuteTime = now\r\n        if (timeoutId) {\r\n          this.clearTimeout(timeoutId)\r\n          timeoutId = null\r\n        }\r\n        lastResult = func.apply(this._parent, lastArgs)\r\n      } else if (timeoutId === null && trailing) {\r\n        timeoutId = this.setTimeout(callback, waitLength)\r\n      }\r\n\r\n      return lastResult\r\n    }\r\n\r\n    // tslint:disable-next-line:no-any\r\n    let resultFunction: () => T = (...args: any[]) => {\r\n      lastArgs = args\r\n      return callback(true)\r\n    }\r\n\r\n    return resultFunction\r\n  }\r\n\r\n  /**\r\n   * Creates a function that will delay the execution of func until after wait milliseconds have\r\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\r\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\r\n   * to the debounced function will return the result of the last func call.\r\n   *\r\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\r\n   * the timeout only if the debounced function is invoked more than once during the wait\r\n   * timeout.\r\n   *\r\n   * @param func - The function to debounce.\r\n   * @param wait - The number of milliseconds to delay.\r\n   * @param options - The options object.\r\n   * @returns The new debounced function.\r\n   */\r\n  public debounce<T extends Function> (\r\n    func: T,\r\n    wait?: number,\r\n    options?: {\r\n      leading?: boolean;\r\n      maxWait?: number;\r\n      trailing?: boolean;\r\n    }\r\n  ): ICancelable<T> & (() => void) {\r\n    if (this._isDisposed) {\r\n      let noOpFunction: ICancelable<T> & (() => T) = (() => {\r\n        /** Do nothing */\r\n      }) as ICancelable<T> & (() => T)\r\n\r\n      noOpFunction.cancel = () => {\r\n\r\n      }\r\n      /* tslint:disable:no-any */\r\n      noOpFunction.flush = (() => null) as any\r\n      /* tslint:enable:no-any */\r\n      noOpFunction.pending = () => false\r\n\r\n      return noOpFunction\r\n    }\r\n\r\n    let waitMS = wait || 0\r\n    let leading = false\r\n    let trailing = true\r\n    let maxWait: number | null = null\r\n    let lastCallTime = 0\r\n    let lastExecuteTime = new Date().getTime()\r\n    let lastResult: T\r\n    // tslint:disable-next-line:no-any\r\n    let lastArgs: any[]\r\n    let timeoutId: number | null = null\r\n\r\n    if (options && typeof options.leading === 'boolean') {\r\n      leading = options.leading\r\n    }\r\n\r\n    if (options && typeof options.trailing === 'boolean') {\r\n      trailing = options.trailing\r\n    }\r\n\r\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\r\n      maxWait = options.maxWait\r\n    }\r\n\r\n    let markExecuted = (time: number) => {\r\n      if (timeoutId) {\r\n        this.clearTimeout(timeoutId)\r\n        timeoutId = null\r\n      }\r\n      lastExecuteTime = time\r\n    }\r\n\r\n    let invokeFunction = (time: number) => {\r\n      markExecuted(time)\r\n      lastResult = func.apply(this._parent, lastArgs)\r\n    }\r\n\r\n    let callback = (userCall?: boolean) => {\r\n      let now = new Date().getTime()\r\n      let executeImmediately = false\r\n      if (userCall) {\r\n        if (leading && now - lastCallTime >= waitMS) {\r\n          executeImmediately = true\r\n        }\r\n        lastCallTime = now\r\n      }\r\n      let delta = now - lastCallTime\r\n      let waitLength = waitMS - delta\r\n      let maxWaitDelta = now - lastExecuteTime\r\n      let maxWaitExpired = false\r\n\r\n      if (maxWait !== null) {\r\n        // maxWait only matters when there is a pending callback\r\n        if (maxWaitDelta >= maxWait && timeoutId) {\r\n          maxWaitExpired = true\r\n        } else {\r\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta)\r\n        }\r\n      }\r\n\r\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\r\n        invokeFunction(now)\r\n      } else if ((timeoutId === null || !userCall) && trailing) {\r\n        timeoutId = this.setTimeout(callback, waitLength)\r\n      }\r\n\r\n      return lastResult\r\n    }\r\n\r\n    let pending = (): boolean => {\r\n      return !!timeoutId\r\n    }\r\n\r\n    let cancel = (): void => {\r\n      if (pending()) {\r\n        // Mark the debounced function as having executed\r\n        markExecuted(new Date().getTime())\r\n      }\r\n    }\r\n\r\n    let flush = (): T => {\r\n      if (pending()) {\r\n        invokeFunction(new Date().getTime())\r\n      }\r\n\r\n      return lastResult\r\n    }\r\n\r\n    // tslint:disable-next-line:no-any\r\n    let resultFunction: ICancelable<T> & (() => T) = ((...args: any[]) => {\r\n      lastArgs = args\r\n      return callback(true)\r\n    }) as ICancelable<T> & (() => T)\r\n\r\n    resultFunction.cancel = cancel\r\n    resultFunction.flush = flush\r\n    resultFunction.pending = pending\r\n\r\n    return resultFunction\r\n  }\r\n\r\n  public requestAnimationFrame (callback: () => void, targetElement?: Element | null): number {\r\n    let animationFrameId = 0\r\n    const win = getWindow(targetElement)!\r\n\r\n    if (!this._isDisposed) {\r\n      if (!this._animationFrameIds) {\r\n        this._animationFrameIds = {}\r\n      }\r\n\r\n      /* tslint:disable:ban-native-functions */\r\n      let animationFrameCallback = () => {\r\n        try {\r\n          // Now delete the record and call the callback.\r\n          if (this._animationFrameIds) {\r\n            delete this._animationFrameIds[animationFrameId]\r\n          }\r\n\r\n          callback.apply(this._parent)\r\n        } catch (e) {\r\n          this._logError(e)\r\n        }\r\n      }\r\n\r\n      animationFrameId = win.requestAnimationFrame\r\n        ? win.requestAnimationFrame(animationFrameCallback)\r\n        : win.setTimeout(animationFrameCallback, 0)\r\n      /* tslint:enable:ban-native-functions */\r\n\r\n      this._animationFrameIds[animationFrameId] = true\r\n    }\r\n\r\n    return animationFrameId\r\n  }\r\n\r\n  public cancelAnimationFrame (id: number, targetElement?: Element | null): void {\r\n    const win = getWindow(targetElement)!\r\n\r\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\r\n      /* tslint:disable:ban-native-functions */\r\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id)\r\n      /* tslint:enable:ban-native-functions */\r\n      delete this._animationFrameIds[id]\r\n    }\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  protected _logError (e: any): void {\r\n    if (this._onErrorHandler) {\r\n      this._onErrorHandler(e)\r\n    }\r\n  }\r\n}\r\n\r\nexport type ICancelable<T> = {\r\n  flush: () => T;\r\n  cancel: () => void;\r\n  pending: () => boolean;\r\n};\r\n","import { getVirtualParent } from './getVirtualParent'\r\n/**\r\n * Gets the element which is the parent of a given element.\r\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\r\n * real DOM parent when present.\r\n *\r\n * @public\r\n */\r\nexport function getParent (child: HTMLElement, allowVirtualParents: boolean = true): HTMLElement | null {\r\n  return child && ((allowVirtualParents && getVirtualParent(child)) || (child.parentNode && (child.parentNode as HTMLElement)))\r\n}\r\n","import { isVirtualElement } from './isVirtualElement'\r\n/**\r\n * Gets the virtual parent given the child element, if it exists.\r\n *\r\n * @public\r\n */\r\nexport function getVirtualParent (child: HTMLElement): HTMLElement | undefined {\r\n  let parent: HTMLElement | undefined\r\n  if (child && isVirtualElement(child)) {\r\n    parent = child._virtual.parent\r\n  }\r\n  return parent\r\n}\r\n","\r\nimport { IVirtualElement } from './IVirtualElement'\r\n/**\r\n * Determines whether or not an element has the virtual hierarchy extension.\r\n *\r\n * @public\r\n */\r\nexport function isVirtualElement (element: HTMLElement | IVirtualElement): element is IVirtualElement {\r\n  return element && !!(<IVirtualElement>element)._virtual\r\n}\r\n","import { findElementRecursive } from './findElementRecursive'\r\n/**\r\n * Determines if an element, or any of its ancestors, contain the given attribute\r\n * @param element - element to start searching at\r\n * @param attribute - the attribute to search for\r\n * @returns the value of the first instance found\r\n */\r\nexport function elementContainsAttribute (element: HTMLElement, attribute: string): string | null {\r\n  let elementMatch = findElementRecursive(element, (testElement: HTMLElement) => testElement.hasAttribute(attribute))\r\n  return elementMatch && elementMatch.getAttribute(attribute)\r\n}\r\n","import { getParent } from './getParent'\r\n/**\r\n * Finds the first parent element where the matchFunction returns true\r\n * @param element - element to start searching at\r\n * @param matchFunction - the function that determines if the element is a match\r\n * @returns the matched element or null no match was found\r\n */\r\nexport function findElementRecursive (element: HTMLElement | null, matchFunction: (element: HTMLElement) => boolean): HTMLElement | null {\r\n  if (!element || element === document.body) {\r\n    return null\r\n  }\r\n  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction)\r\n}\r\n","import { elementContainsAttribute } from './dom/elementContainsAttribute'\r\nimport { elementContains } from './dom/elementContains'\r\nimport { getParent } from './dom/getParent'\r\nimport { getWindow } from './dom/getWindow'\r\nimport { getDocument } from './dom/getDocument'\r\n\r\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable'\r\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible'\r\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id'\r\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone'\r\n\r\n/**\r\n * Gets the first focusable element.\r\n *\r\n * @public\r\n */\r\nexport function getFirstFocusable (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean\r\n): HTMLElement | null {\r\n  return getNextElement(\r\n    rootElement,\r\n    currentElement,\r\n    true /* checkNode */,\r\n    false /* suppressParentTraversal */,\r\n    false /* suppressChildTraversal */,\r\n    includeElementsInFocusZones\r\n  )\r\n}\r\n\r\n/**\r\n * Gets the last focusable element.\r\n *\r\n * @public\r\n */\r\nexport function getLastFocusable (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean\r\n): HTMLElement | null {\r\n  return getPreviousElement(\r\n    rootElement,\r\n    currentElement,\r\n    true /* checkNode */,\r\n    false /* suppressParentTraversal */,\r\n    true /* traverseChildren */,\r\n    includeElementsInFocusZones\r\n  )\r\n}\r\n\r\n/**\r\n * Gets the first tabbable element.\r\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\r\n * @param rootElement - The parent element to search beneath.\r\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\r\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\r\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\r\n * @param checkNode - Include currentElement in search when true. Defaults to true.\r\n * @public\r\n */\r\nexport function getFirstTabbable (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean,\r\n  checkNode: boolean = true\r\n): HTMLElement | null {\r\n  return getNextElement(\r\n    rootElement,\r\n    currentElement,\r\n    checkNode,\r\n    false /* suppressParentTraversal */,\r\n    false /* suppressChildTraversal */,\r\n    includeElementsInFocusZones,\r\n    false /* allowFocusRoot */,\r\n    true /* tabbable */\r\n  )\r\n}\r\n\r\n/**\r\n * Gets the last tabbable element.\r\n * The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1.\r\n * @param rootElement - The parent element to search beneath.\r\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\r\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\r\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\r\n * @param checkNode - Include currentElement in search when true. Defaults to true.\r\n * @public\r\n */\r\nexport function getLastTabbable (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean,\r\n  checkNode: boolean = true\r\n): HTMLElement | null {\r\n  return getPreviousElement(\r\n    rootElement,\r\n    currentElement,\r\n    checkNode,\r\n    false /* suppressParentTraversal */,\r\n    true /* traverseChildren */,\r\n    includeElementsInFocusZones,\r\n    false /* allowFocusRoot */,\r\n    true /* tabbable */\r\n  )\r\n}\r\n\r\n/**\r\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\r\n *\r\n * @public\r\n * @param rootElement - Element to start the search for a focusable child.\r\n * @returns True if focus was set, false if it was not.\r\n */\r\nexport function focusFirstChild (rootElement: HTMLElement): boolean {\r\n  let element: HTMLElement | null = getNextElement(rootElement, rootElement, true, false, false, true)\r\n\r\n  if (element) {\r\n    focusAsync(element)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Traverse to find the previous element.\r\n * If tabbable is true, the element must have tabIndex != -1.\r\n *\r\n * @public\r\n */\r\nexport function getPreviousElement (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement | null,\r\n  checkNode?: boolean,\r\n  suppressParentTraversal?: boolean,\r\n  traverseChildren?: boolean,\r\n  includeElementsInFocusZones?: boolean,\r\n  allowFocusRoot?: boolean,\r\n  tabbable?: boolean\r\n): HTMLElement | null {\r\n  if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\r\n    return null\r\n  }\r\n\r\n  let isCurrentElementVisible = isElementVisible(currentElement)\r\n\r\n  // Check its children.\r\n  if (\r\n    traverseChildren &&\r\n    isCurrentElementVisible &&\r\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\r\n  ) {\r\n    const childMatch = getPreviousElement(\r\n      rootElement,\r\n      currentElement.lastElementChild as HTMLElement,\r\n      true,\r\n      true,\r\n      true,\r\n      includeElementsInFocusZones,\r\n      allowFocusRoot,\r\n      tabbable\r\n    )\r\n\r\n    if (childMatch) {\r\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\r\n        return childMatch\r\n      }\r\n\r\n      const childMatchSiblingMatch = getPreviousElement(\r\n        rootElement,\r\n        childMatch.previousElementSibling as HTMLElement,\r\n        true,\r\n        true,\r\n        true,\r\n        includeElementsInFocusZones,\r\n        allowFocusRoot,\r\n        tabbable\r\n      )\r\n      if (childMatchSiblingMatch) {\r\n        return childMatchSiblingMatch\r\n      }\r\n\r\n      let childMatchParent = childMatch.parentElement\r\n\r\n      // At this point if we have not found any potential matches\r\n      // start looking at the rest of the subtree under the currentParent.\r\n      // NOTE: We do not want to recurse here because doing so could\r\n      // cause elements to get skipped.\r\n      while (childMatchParent && childMatchParent !== currentElement) {\r\n        const childMatchParentMatch = getPreviousElement(\r\n          rootElement,\r\n          childMatchParent.previousElementSibling as HTMLElement,\r\n          true,\r\n          true,\r\n          true,\r\n          includeElementsInFocusZones,\r\n          allowFocusRoot,\r\n          tabbable\r\n        )\r\n\r\n        if (childMatchParentMatch) {\r\n          return childMatchParentMatch\r\n        }\r\n\r\n        childMatchParent = childMatchParent.parentElement\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check the current node, if it's not the first traversal.\r\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\r\n    return currentElement\r\n  }\r\n\r\n  // Check its previous sibling.\r\n  const siblingMatch = getPreviousElement(\r\n    rootElement,\r\n    currentElement.previousElementSibling as HTMLElement,\r\n    true,\r\n    true,\r\n    true,\r\n    includeElementsInFocusZones,\r\n    allowFocusRoot,\r\n    tabbable\r\n  )\r\n\r\n  if (siblingMatch) {\r\n    return siblingMatch\r\n  }\r\n\r\n  // Check its parent.\r\n  if (!suppressParentTraversal) {\r\n    return getPreviousElement(\r\n      rootElement,\r\n      currentElement.parentElement,\r\n      true,\r\n      false,\r\n      false,\r\n      includeElementsInFocusZones,\r\n      allowFocusRoot,\r\n      tabbable\r\n    )\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n/**\r\n * Traverse to find the next focusable element.\r\n * If tabbable is true, the element must have tabIndex != -1.\r\n *\r\n * @public\r\n * @param checkNode - Include currentElement in search when true.\r\n */\r\nexport function getNextElement (\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement | null,\r\n  checkNode?: boolean,\r\n  suppressParentTraversal?: boolean,\r\n  suppressChildTraversal?: boolean,\r\n  includeElementsInFocusZones?: boolean,\r\n  allowFocusRoot?: boolean,\r\n  tabbable?: boolean\r\n): HTMLElement | null {\r\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\r\n    return null\r\n  }\r\n\r\n  let isCurrentElementVisible = isElementVisible(currentElement)\r\n\r\n  // Check the current node, if it's not the first traversal.\r\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\r\n    return currentElement\r\n  }\r\n\r\n  // Check its children.\r\n  if (\r\n    !suppressChildTraversal &&\r\n    isCurrentElementVisible &&\r\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\r\n  ) {\r\n    const childMatch = getNextElement(\r\n      rootElement,\r\n      currentElement.firstElementChild as HTMLElement,\r\n      true,\r\n      true,\r\n      false,\r\n      includeElementsInFocusZones,\r\n      allowFocusRoot,\r\n      tabbable\r\n    )\r\n\r\n    if (childMatch) {\r\n      return childMatch\r\n    }\r\n  }\r\n\r\n  if (currentElement === rootElement) {\r\n    return null\r\n  }\r\n\r\n  // Check its sibling.\r\n  const siblingMatch = getNextElement(\r\n    rootElement,\r\n    currentElement.nextElementSibling as HTMLElement,\r\n    true,\r\n    true,\r\n    false,\r\n    includeElementsInFocusZones,\r\n    allowFocusRoot,\r\n    tabbable\r\n  )\r\n\r\n  if (siblingMatch) {\r\n    return siblingMatch\r\n  }\r\n\r\n  if (!suppressParentTraversal) {\r\n    return getNextElement(\r\n      rootElement,\r\n      currentElement.parentElement,\r\n      false,\r\n      false,\r\n      true,\r\n      includeElementsInFocusZones,\r\n      allowFocusRoot,\r\n      tabbable\r\n    )\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n/**\r\n * Determines if an element is visible.\r\n *\r\n * @public\r\n */\r\nexport function isElementVisible (element: HTMLElement | undefined | null): boolean {\r\n  // If the element is not valid, return false.\r\n  if (!element || !element.getAttribute) {\r\n    return false\r\n  }\r\n\r\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE)\r\n\r\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\r\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\r\n    return visibilityAttribute === 'true'\r\n  }\r\n\r\n  // Fallback to other methods of determining actual visibility.\r\n  return (\r\n    element.offsetHeight !== 0 ||\r\n    element.offsetParent !== null ||\r\n    // tslint:disable-next-line:no-any\r\n    (element as any).isVisible === true\r\n  ) // used as a workaround for testing.\r\n}\r\n\r\n/**\r\n * Determines if an element can receive focus programmatically or via a mouse click.\r\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1.\r\n *\r\n * @public\r\n */\r\nexport function isElementTabbable (element: HTMLElement, checkTabIndex?: boolean): boolean {\r\n  // If this element is null or is disabled, it is not considered tabbable.\r\n  if (!element || (element as HTMLButtonElement).disabled) {\r\n    return false\r\n  }\r\n\r\n  let tabIndex = 0\r\n  let tabIndexAttributeValue: string | null = null\r\n\r\n  if (element && element.getAttribute) {\r\n    tabIndexAttributeValue = element.getAttribute('tabIndex')\r\n\r\n    if (tabIndexAttributeValue) {\r\n      tabIndex = parseInt(tabIndexAttributeValue, 10)\r\n    }\r\n  }\r\n\r\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null\r\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0\r\n\r\n  const result =\r\n    !!element &&\r\n    isFocusableAttribute !== 'false' &&\r\n    (element.tagName === 'A' ||\r\n      element.tagName === 'BUTTON' ||\r\n      element.tagName === 'INPUT' ||\r\n      element.tagName === 'TEXTAREA' ||\r\n      isFocusableAttribute === 'true' ||\r\n      isTabIndexSet)\r\n\r\n  return checkTabIndex ? tabIndex !== -1 && result : result\r\n}\r\n\r\n/**\r\n * Determines if a given element is a focus zone.\r\n *\r\n * @public\r\n */\r\nexport function isElementFocusZone (element?: HTMLElement): boolean {\r\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE))\r\n}\r\n\r\n/**\r\n * Determines if a given element is a focus sub zone.\r\n *\r\n * @public\r\n */\r\nexport function isElementFocusSubZone (element?: HTMLElement): boolean {\r\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true')\r\n}\r\n\r\n/**\r\n * Determines if an element, or any of its children, contain focus.\r\n *\r\n * @public\r\n */\r\nexport function doesElementContainFocus (element: HTMLElement): boolean {\r\n  let document = getDocument(element)\r\n  let currentActiveElement: HTMLElement | undefined = document && (document.activeElement as HTMLElement)\r\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\r\n * @param element - element to start searching from\r\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\r\n * @returns true if focus should wrap, false otherwise\r\n */\r\nexport function shouldWrapFocus (element: HTMLElement, noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap'): boolean {\r\n  return elementContainsAttribute(element, noWrapDataAttribute) !== 'true'\r\n}\r\n\r\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined\r\n\r\n/**\r\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\r\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\r\n * only the latest called focusAsync element will actually be focused\r\n * @param element - The element to focus\r\n */\r\nexport function focusAsync (element: HTMLElement | { focus: () => void } | undefined | null): void {\r\n  if (element) {\r\n    // An element was already queued to be focused, so replace that one with the new element\r\n    if (targetToFocusOnNextRepaint) {\r\n      targetToFocusOnNextRepaint = element\r\n      return\r\n    }\r\n\r\n    targetToFocusOnNextRepaint = element\r\n\r\n    const win = getWindow(element as Element)\r\n\r\n    if (win) {\r\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\r\n      win.requestAnimationFrame(() => {\r\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus()\r\n\r\n        // We are done focusing for this frame, so reset the queued focus element\r\n        targetToFocusOnNextRepaint = undefined\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Finds the closest focusable element via an index path from a parent. See\r\n * `getElementIndexPath` for getting an index path from an element to a child.\r\n */\r\nexport function getFocusableByIndexPath (parent: HTMLElement, path: number[]): HTMLElement | undefined {\r\n  let element = parent\r\n\r\n  for (const index of path) {\r\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement\r\n\r\n    if (!nextChild) {\r\n      break\r\n    }\r\n    element = nextChild\r\n  }\r\n\r\n  element =\r\n    isElementTabbable(element) && isElementVisible(element)\r\n      ? element\r\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!\r\n\r\n  return element as HTMLElement\r\n}\r\n\r\n/**\r\n * Finds the element index path from a parent element to a child element.\r\n *\r\n * If you had this node structure: \"A has children [B, C] and C has child D\",\r\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\r\n */\r\nexport function getElementIndexPath (fromElement: HTMLElement, toElement: HTMLElement): number[] {\r\n  const path: number[] = []\r\n\r\n  // eslint-disable-next-line\r\n  while (toElement && fromElement && toElement !== fromElement) {\r\n    const parent = getParent(toElement, true)\r\n\r\n    if (parent === null) {\r\n      return []\r\n    }\r\n\r\n    path.unshift(Array.prototype.indexOf.call(parent.children, toElement))\r\n    toElement = parent\r\n  }\r\n\r\n  return path\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { __assign } from \"tslib\";\nexport var InjectionMode = {\n    /**\n     * Avoids style injection, use getRules() to read the styles.\n     */\n    none: 0,\n    /**\n     * Inserts rules using the insertRule api.\n     */\n    insertNode: 1,\n    /**\n     * Appends rules using appendChild.\n     */\n    appendChild: 2\n};\nvar STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nvar REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\n// tslint:disable-next-line:no-any\nvar _global = {};\n// Grab window.\ntry {\n    _global = window;\n}\ncatch (_a) {\n    /* leave as blank object */\n}\nvar _stylesheet;\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nvar Stylesheet = /** @class */ (function () {\n    function Stylesheet(config) {\n        this._rules = [];\n        this._preservedRules = [];\n        this._rulesToInsert = [];\n        this._counter = 0;\n        this._keyToClassName = {};\n        this._onResetCallbacks = [];\n        // tslint:disable-next-line:no-any\n        this._classNameToArgs = {};\n        this._config = __assign({ injectionMode: InjectionMode.insertNode, defaultPrefix: 'css', namespace: undefined, cspSettings: undefined }, config);\n    }\n    /**\n     * Gets the singleton instance.\n     */\n    Stylesheet.getInstance = function () {\n        // tslint:disable-next-line:no-any\n        _stylesheet = _global[STYLESHEET_SETTING];\n        if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n            // tslint:disable-next-line:no-string-literal\n            var fabricConfig = (_global && _global['FabricConfig']) || {};\n            _stylesheet = _global[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);\n        }\n        return _stylesheet;\n    };\n    /**\n     * Configures the stylesheet.\n     */\n    Stylesheet.prototype.setConfig = function (config) {\n        this._config = __assign(__assign({}, this._config), config);\n    };\n    /**\n     * Configures a reset callback.\n     *\n     * @param callback - A callback which will be called when the Stylesheet is reset.\n     */\n    Stylesheet.prototype.onReset = function (callback) {\n        this._onResetCallbacks.push(callback);\n    };\n    /**\n     * Generates a unique classname.\n     *\n     * @param displayName - Optional value to use as a prefix.\n     */\n    Stylesheet.prototype.getClassName = function (displayName) {\n        var namespace = this._config.namespace;\n        var prefix = displayName || this._config.defaultPrefix;\n        return \"\" + (namespace ? namespace + '-' : '') + prefix + \"-\" + this._counter++;\n    };\n    /**\n     * Used internally to cache information about a class which was\n     * registered with the stylesheet.\n     */\n    Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {\n        this._keyToClassName[key] = className;\n        this._classNameToArgs[className] = {\n            args: args,\n            rules: rules\n        };\n    };\n    /**\n     * Gets the appropriate classname given a key which was previously\n     * registered using cacheClassName.\n     */\n    Stylesheet.prototype.classNameFromKey = function (key) {\n        return this._keyToClassName[key];\n    };\n    /**\n     * Gets the arguments associated with a given classname which was\n     * previously registered using cacheClassName.\n     */\n    Stylesheet.prototype.argsFromClassName = function (className) {\n        var entry = this._classNameToArgs[className];\n        return entry && entry.args;\n    };\n    /**\n     * Gets the arguments associated with a given classname which was\n     * previously registered using cacheClassName.\n     */\n    Stylesheet.prototype.insertedRulesFromClassName = function (className) {\n        var entry = this._classNameToArgs[className];\n        return entry && entry.rules;\n    };\n    /**\n     * Inserts a css rule into the stylesheet.\n     * @param preserve - Preserves the rule beyond a reset boundary.\n     */\n    Stylesheet.prototype.insertRule = function (rule, preserve) {\n        var injectionMode = this._config.injectionMode;\n        var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n        if (preserve) {\n            this._preservedRules.push(rule);\n        }\n        if (element) {\n            switch (this._config.injectionMode) {\n                case InjectionMode.insertNode:\n                    var sheet = element.sheet;\n                    try {\n                        sheet.insertRule(rule, sheet.cssRules.length);\n                    }\n                    catch (e) {\n                        // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n                        // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n                        // which could be slower and bulkier.\n                    }\n                    break;\n                case InjectionMode.appendChild:\n                    element.appendChild(document.createTextNode(rule));\n                    break;\n            }\n        }\n        else {\n            this._rules.push(rule);\n        }\n        if (this._config.onInsertRule) {\n            this._config.onInsertRule(rule);\n        }\n    };\n    /**\n     * Gets all rules registered with the stylesheet; only valid when\n     * using InsertionMode.none.\n     */\n    Stylesheet.prototype.getRules = function (includePreservedRules) {\n        return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('') + this._rulesToInsert.join('');\n    };\n    /**\n     * Resets the internal state of the stylesheet. Only used in server\n     * rendered scenarios where we're using InsertionMode.none.\n     */\n    Stylesheet.prototype.reset = function () {\n        this._rules = [];\n        this._rulesToInsert = [];\n        this._counter = 0;\n        this._classNameToArgs = {};\n        this._keyToClassName = {};\n        this._onResetCallbacks.forEach(function (callback) { return callback(); });\n    };\n    // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n    Stylesheet.prototype.resetKeys = function () {\n        this._keyToClassName = {};\n    };\n    Stylesheet.prototype._getStyleElement = function () {\n        var _this = this;\n        if (!this._styleElement && typeof document !== 'undefined') {\n            this._styleElement = this._createStyleElement();\n            if (!REUSE_STYLE_NODE) {\n                // Reset the style element on the next frame.\n                window.requestAnimationFrame(function () {\n                    _this._styleElement = undefined;\n                });\n            }\n        }\n        return this._styleElement;\n    };\n    Stylesheet.prototype._createStyleElement = function () {\n        var head = document.head;\n        var styleElement = document.createElement('style');\n        styleElement.setAttribute('data-merge-styles', 'true');\n        var cspSettings = this._config.cspSettings;\n        if (cspSettings) {\n            if (cspSettings.nonce) {\n                styleElement.setAttribute('nonce', cspSettings.nonce);\n            }\n        }\n        if (this._lastStyleElement) {\n            // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n            head.insertBefore(styleElement, this._lastStyleElement.nextElementSibling);\n        }\n        else {\n            var placeholderStyleTag = this._findPlaceholderStyleTag();\n            if (placeholderStyleTag) {\n                head.insertBefore(styleElement, placeholderStyleTag.nextElementSibling);\n            }\n            else {\n                head.insertBefore(styleElement, head.childNodes[0]);\n            }\n        }\n        this._lastStyleElement = styleElement;\n        return styleElement;\n    };\n    Stylesheet.prototype._findPlaceholderStyleTag = function () {\n        var head = document.head;\n        if (head) {\n            return head.querySelector('style[data-merge-styles]');\n        }\n        return null;\n    };\n    return Stylesheet;\n}());\nexport { Stylesheet };\n//# sourceMappingURL=Stylesheet.js.map","import { Stylesheet } from './Stylesheet';\n/**\n * Separates the classes and style objects. Any classes that are pre-registered\n * args are auto expanded into objects.\n */\nexport function extractStyleParts() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var classes = [];\n    var objects = [];\n    var stylesheet = Stylesheet.getInstance();\n    function _processArgs(argsList) {\n        for (var _i = 0, argsList_1 = argsList; _i < argsList_1.length; _i++) {\n            var arg = argsList_1[_i];\n            if (arg) {\n                if (typeof arg === 'string') {\n                    if (arg.indexOf(' ') >= 0) {\n                        _processArgs(arg.split(' '));\n                    }\n                    else {\n                        var translatedArgs = stylesheet.argsFromClassName(arg);\n                        if (translatedArgs) {\n                            _processArgs(translatedArgs);\n                        }\n                        else {\n                            // Avoid adding the same class twice.\n                            if (classes.indexOf(arg) === -1) {\n                                classes.push(arg);\n                            }\n                        }\n                    }\n                }\n                else if (Array.isArray(arg)) {\n                    _processArgs(arg);\n                }\n                else if (typeof arg === 'object') {\n                    objects.push(arg);\n                }\n            }\n        }\n    }\n    _processArgs(args);\n    return {\n        classes: classes,\n        objects: objects\n    };\n}\n//# sourceMappingURL=extractStyleParts.js.map","/**\n * Sets the current RTL value.\n */\nexport function setRTL(isRTL) {\n    if (_rtl !== isRTL) {\n        _rtl = isRTL;\n    }\n}\n/**\n * Gets the current RTL value.\n */\nexport function getRTL() {\n    if (_rtl === undefined) {\n        _rtl = typeof document !== 'undefined' && !!document.documentElement && document.documentElement.getAttribute('dir') === 'rtl';\n    }\n    return _rtl;\n}\nvar _rtl = getRTL();\nexport function getStyleOptions() {\n    return {\n        rtl: getRTL()\n    };\n}\n//# sourceMappingURL=StyleOptionsState.js.map","var rules = {};\nexport function kebabRules(rulePairs, index) {\n    var rule = rulePairs[index];\n    rulePairs[index] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n//# sourceMappingURL=kebabRules.js.map","var _vendorSettings;\nexport function getVendorSettings() {\n    if (!_vendorSettings) {\n        var doc = typeof document !== 'undefined' ? document : undefined;\n        var nav = typeof navigator !== 'undefined' ? navigator : undefined;\n        var userAgent = nav ? nav.userAgent.toLowerCase() : undefined;\n        if (!doc) {\n            _vendorSettings = {\n                isWebkit: true,\n                isMoz: true,\n                isOpera: true,\n                isMs: true\n            };\n        }\n        else {\n            _vendorSettings = {\n                isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),\n                isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),\n                isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),\n                isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)))\n            };\n        }\n    }\n    return _vendorSettings;\n}\n/**\n * Sets the vendor settings for prefixing and vendor specific operations.\n */\nexport function setVendorSettings(vendorSettings) {\n    _vendorSettings = vendorSettings;\n}\n//# sourceMappingURL=getVendorSettings.js.map","import { getVendorSettings } from '../getVendorSettings';\nvar autoPrefixNames = {\n    'user-select': 1\n};\nexport function prefixRules(rulePairs, index) {\n    var vendorSettings = getVendorSettings();\n    var name = rulePairs[index];\n    if (autoPrefixNames[name]) {\n        var value = rulePairs[index + 1];\n        if (autoPrefixNames[name]) {\n            if (vendorSettings.isWebkit) {\n                rulePairs.push('-webkit-' + name, value);\n            }\n            if (vendorSettings.isMoz) {\n                rulePairs.push('-moz-' + name, value);\n            }\n            if (vendorSettings.isMs) {\n                rulePairs.push('-ms-' + name, value);\n            }\n            if (vendorSettings.isOpera) {\n                rulePairs.push('-o-' + name, value);\n            }\n        }\n    }\n}\n//# sourceMappingURL=prefixRules.js.map","var NON_PIXEL_NUMBER_PROPS = [\n    'column-count',\n    'font-weight',\n    'flex',\n    'flex-grow',\n    'flex-shrink',\n    'fill-opacity',\n    'opacity',\n    'order',\n    'z-index',\n    'zoom'\n];\nexport function provideUnits(rulePairs, index) {\n    var name = rulePairs[index];\n    var value = rulePairs[index + 1];\n    if (typeof value === 'number') {\n        var unit = NON_PIXEL_NUMBER_PROPS.indexOf(name) === -1 ? 'px' : '';\n        rulePairs[index + 1] = \"\" + value + unit;\n    }\n}\n//# sourceMappingURL=provideUnits.js.map","var _a;\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar NO_FLIP = '@noflip';\nvar NAME_REPLACEMENTS = (_a = {},\n    _a[LEFT] = RIGHT,\n    _a[RIGHT] = LEFT,\n    _a);\nvar VALUE_REPLACEMENTS = {\n    'w-resize': 'e-resize',\n    'sw-resize': 'se-resize',\n    'nw-resize': 'ne-resize'\n};\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options, rulePairs, index) {\n    if (options.rtl) {\n        var name_1 = rulePairs[index];\n        if (!name_1) {\n            return;\n        }\n        var value = rulePairs[index + 1];\n        if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n            rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n        }\n        else if (name_1.indexOf(LEFT) >= 0) {\n            rulePairs[index] = name_1.replace(LEFT, RIGHT);\n        }\n        else if (name_1.indexOf(RIGHT) >= 0) {\n            rulePairs[index] = name_1.replace(RIGHT, LEFT);\n        }\n        else if (String(value).indexOf(LEFT) >= 0) {\n            rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n        }\n        else if (String(value).indexOf(RIGHT) >= 0) {\n            rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n        }\n        else if (NAME_REPLACEMENTS[name_1]) {\n            rulePairs[index] = NAME_REPLACEMENTS[name_1];\n        }\n        else if (VALUE_REPLACEMENTS[value]) {\n            rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n        }\n        else {\n            switch (name_1) {\n                case 'margin':\n                case 'padding':\n                    rulePairs[index + 1] = flipQuad(value);\n                    break;\n                case 'box-shadow':\n                    rulePairs[index + 1] = negateNum(value, 0);\n                    break;\n            }\n        }\n    }\n}\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value, partIndex) {\n    var parts = value.split(' ');\n    var numberVal = parseInt(parts[partIndex], 10);\n    parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n    return parts.join(' ');\n}\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value) {\n    if (typeof value === 'string') {\n        var parts = value.split(' ');\n        if (parts.length === 4) {\n            return parts[0] + \" \" + parts[3] + \" \" + parts[2] + \" \" + parts[1];\n        }\n    }\n    return value;\n}\n//# sourceMappingURL=rtlifyRules.js.map","import { __spreadArrays } from \"tslib\";\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nvar DISPLAY_NAME = 'displayName';\nfunction getDisplayName(rules) {\n    var rootStyle = rules && rules['&'];\n    return rootStyle ? rootStyle.displayName : undefined;\n}\nvar globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals) {\n    // We the selector does not have a :global() we can shortcut\n    if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n        return selectorWithGlobals;\n    }\n    var replacementInfo = [];\n    var findGlobal = /\\:global\\((.+?)\\)/g;\n    var match = null;\n    // Create a result list for global selectors so we can replace them.\n    while ((match = findGlobal.exec(selectorWithGlobals))) {\n        // Only if the found selector is a comma separated list we'll process it.\n        if (match[1].indexOf(',') > -1) {\n            replacementInfo.push([\n                match.index,\n                match.index + match[0].length,\n                // Wrap each of the found selectors in :global()\n                match[1]\n                    .split(',')\n                    .map(function (v) { return \":global(\" + v.trim() + \")\"; })\n                    .join(', ')\n            ]);\n        }\n    }\n    // Replace the found selectors with their wrapped variants in reverse order\n    return replacementInfo.reverse().reduce(function (selector, _a) {\n        var matchIndex = _a[0], matchEndIndex = _a[1], replacement = _a[2];\n        var prefix = selector.slice(0, matchIndex);\n        var suffix = selector.slice(matchEndIndex);\n        return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\nfunction expandSelector(newSelector, currentSelector) {\n    if (newSelector.indexOf(':global(') >= 0) {\n        return newSelector.replace(globalSelectorRegExp, '$1');\n    }\n    else if (newSelector.indexOf(':') === 0) {\n        return currentSelector + newSelector;\n    }\n    else if (newSelector.indexOf('&') < 0) {\n        return currentSelector + ' ' + newSelector;\n    }\n    return newSelector;\n}\nfunction extractRules(args, rules, currentSelector) {\n    if (rules === void 0) { rules = { __order: [] }; }\n    if (currentSelector === void 0) { currentSelector = '&'; }\n    var stylesheet = Stylesheet.getInstance();\n    var currentRules = rules[currentSelector];\n    if (!currentRules) {\n        currentRules = {};\n        rules[currentSelector] = currentRules;\n        rules.__order.push(currentSelector);\n    }\n    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n        var arg = args_1[_i];\n        // If the arg is a string, we need to look up the class map and merge.\n        if (typeof arg === 'string') {\n            var expandedRules = stylesheet.argsFromClassName(arg);\n            if (expandedRules) {\n                extractRules(expandedRules, rules, currentSelector);\n            }\n            // Else if the arg is an array, we need to recurse in.\n        }\n        else if (Array.isArray(arg)) {\n            extractRules(arg, rules, currentSelector);\n        }\n        else {\n            // tslint:disable-next-line:no-any\n            for (var prop in arg) {\n                if (prop === 'selectors') {\n                    // tslint:disable-next-line:no-any\n                    var selectors = arg.selectors;\n                    var _loop_1 = function (newSelector) {\n                        if (selectors.hasOwnProperty(newSelector)) {\n                            var selectorValue_1 = selectors[newSelector];\n                            if (newSelector.indexOf('@') === 0) {\n                                newSelector = newSelector + '{' + currentSelector;\n                                extractRules([selectorValue_1], rules, newSelector);\n                            }\n                            else if (newSelector.indexOf(',') > -1) {\n                                expandCommaSeparatedGlobals(newSelector)\n                                    .split(',')\n                                    .map(function (s) { return s.trim(); })\n                                    .forEach(function (separatedSelector) {\n                                    return extractRules([selectorValue_1], rules, expandSelector(separatedSelector, currentSelector));\n                                });\n                            }\n                            else {\n                                extractRules([selectorValue_1], rules, expandSelector(newSelector, currentSelector));\n                            }\n                        }\n                    };\n                    for (var newSelector in selectors) {\n                        _loop_1(newSelector);\n                    }\n                }\n                else {\n                    if (arg[prop] !== undefined) {\n                        // Else, add the rule to the currentSelector.\n                        if (prop === 'margin' || prop === 'padding') {\n                            // tslint:disable-next-line:no-any\n                            expandQuads(currentRules, prop, arg[prop]);\n                        }\n                        else {\n                            // tslint:disable-next-line:no-any\n                            currentRules[prop] = arg[prop];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return rules;\n}\nfunction expandQuads(currentRules, name, value) {\n    var parts = typeof value === 'string' ? value.split(' ') : [value];\n    currentRules[name + 'Top'] = parts[0];\n    currentRules[name + 'Right'] = parts[1] || parts[0];\n    currentRules[name + 'Bottom'] = parts[2] || parts[0];\n    currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\nfunction getKeyForRules(options, rules) {\n    var serialized = [options.rtl ? 'rtl' : 'ltr'];\n    var hasProps = false;\n    for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {\n        var selector = _a[_i];\n        serialized.push(selector);\n        var rulesForSelector = rules[selector];\n        for (var propName in rulesForSelector) {\n            if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n                hasProps = true;\n                serialized.push(propName, rulesForSelector[propName]);\n            }\n        }\n    }\n    return hasProps ? serialized.join('') : undefined;\n}\nexport function serializeRuleEntries(options, ruleEntries) {\n    if (!ruleEntries) {\n        return '';\n    }\n    var allEntries = [];\n    for (var entry in ruleEntries) {\n        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n            allEntries.push(entry, ruleEntries[entry]);\n        }\n    }\n    // Apply transforms.\n    for (var i = 0; i < allEntries.length; i += 2) {\n        kebabRules(allEntries, i);\n        provideUnits(allEntries, i);\n        rtlifyRules(options, allEntries, i);\n        prefixRules(allEntries, i);\n    }\n    // Apply punctuation.\n    for (var i = 1; i < allEntries.length; i += 4) {\n        allEntries.splice(i, 1, ':', allEntries[i], ';');\n    }\n    return allEntries.join('');\n}\nexport function styleToRegistration(options) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var rules = extractRules(args);\n    var key = getKeyForRules(options, rules);\n    if (key) {\n        var stylesheet = Stylesheet.getInstance();\n        var registration = {\n            className: stylesheet.classNameFromKey(key),\n            key: key,\n            args: args\n        };\n        if (!registration.className) {\n            registration.className = stylesheet.getClassName(getDisplayName(rules));\n            var rulesToInsert = [];\n            for (var _a = 0, _b = rules.__order; _a < _b.length; _a++) {\n                var selector = _b[_a];\n                rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n            }\n            registration.rulesToInsert = rulesToInsert;\n        }\n        return registration;\n    }\n}\nexport function applyRegistration(registration) {\n    var stylesheet = Stylesheet.getInstance();\n    var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;\n    if (rulesToInsert) {\n        // rulesToInsert is an ordered array of selector/rule pairs.\n        for (var i = 0; i < rulesToInsert.length; i += 2) {\n            var rules = rulesToInsert[i + 1];\n            if (rules) {\n                var selector = rulesToInsert[i];\n                selector = selector.replace(/&/g, '.' + registration.className);\n                // Insert. Note if a media query, we must close the query with a final bracket.\n                var processedRule = selector + \"{\" + rules + \"}\" + (selector.indexOf('@') === 0 ? '}' : '');\n                stylesheet.insertRule(processedRule);\n            }\n        }\n        stylesheet.cacheClassName(className, key, args, rulesToInsert);\n    }\n}\nexport function styleToClassName(options) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var registration = styleToRegistration.apply(void 0, __spreadArrays([options], args));\n    if (registration) {\n        applyRegistration(registration);\n        return registration.className;\n    }\n    return '';\n}\n//# sourceMappingURL=styleToClassName.js.map","import { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets() {\n    var styleSets = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        styleSets[_i] = arguments[_i];\n    }\n    return mergeCssSets(styleSets, getStyleOptions());\n}\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(styleSets, options) {\n    // tslint:disable-next-line:no-any\n    var classNameSet = { subComponentStyles: {} };\n    var styleSet = styleSets[0];\n    if (!styleSet && styleSets.length <= 1) {\n        return { subComponentStyles: {} };\n    }\n    var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);\n    var registrations = [];\n    for (var styleSetArea in concatenatedStyleSet) {\n        if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n            if (styleSetArea === 'subComponentStyles') {\n                classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n                continue;\n            }\n            var styles = concatenatedStyleSet[styleSetArea];\n            var _a = extractStyleParts(styles), classes = _a.classes, objects = _a.objects;\n            var registration = styleToRegistration(options || {}, { displayName: styleSetArea }, objects);\n            registrations.push(registration);\n            if (registration) {\n                classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n            }\n        }\n    }\n    for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {\n        var registration = registrations_1[_i];\n        if (registration) {\n            applyRegistration(registration);\n        }\n    }\n    return classNameSet;\n}\n//# sourceMappingURL=mergeStyleSets.js.map","import { __spreadArrays } from \"tslib\";\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\n */\nexport function concatStyleSets() {\n    var styleSets = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        styleSets[_i] = arguments[_i];\n    }\n    if (styleSets && styleSets.length === 1 && styleSets[0] && !styleSets[0].subComponentStyles) {\n        return styleSets[0];\n    }\n    var mergedSet = {};\n    // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.\n    var workingSubcomponentStyles = {};\n    for (var _a = 0, styleSets_1 = styleSets; _a < styleSets_1.length; _a++) {\n        var currentSet = styleSets_1[_a];\n        if (currentSet) {\n            for (var prop in currentSet) {\n                if (currentSet.hasOwnProperty(prop)) {\n                    if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {\n                        // subcomponent styles - style functions or objects\n                        var currentComponentStyles = currentSet.subComponentStyles;\n                        for (var subCompProp in currentComponentStyles) {\n                            if (currentComponentStyles.hasOwnProperty(subCompProp)) {\n                                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n                                    workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);\n                                }\n                                else {\n                                    workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];\n                                }\n                            }\n                        }\n                        continue;\n                    }\n                    // the as any casts below is a workaround for ts 2.8.\n                    // todo: remove cast to any in ts 2.9.\n                    var mergedValue = mergedSet[prop];\n                    var currentValue = currentSet[prop];\n                    if (mergedValue === undefined) {\n                        mergedSet[prop] = currentValue;\n                    }\n                    else {\n                        mergedSet[prop] = __spreadArrays((Array.isArray(mergedValue) ? mergedValue : [mergedValue]), (Array.isArray(currentValue) ? currentValue : [currentValue]));\n                    }\n                }\n            }\n        }\n    }\n    if (Object.keys(workingSubcomponentStyles).length > 0) {\n        mergedSet.subComponentStyles = {};\n        var mergedSubStyles = mergedSet.subComponentStyles;\n        var _loop_1 = function (subCompProp) {\n            if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n                var workingSet_1 = workingSubcomponentStyles[subCompProp];\n                mergedSubStyles[subCompProp] = function (styleProps) {\n                    return concatStyleSets.apply(void 0, workingSet_1.map(function (styleFunctionOrObject) {\n                        return typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;\n                    }));\n                };\n            }\n        };\n        // now we process the subcomponent styles if there are any\n        for (var subCompProp in workingSubcomponentStyles) {\n            _loop_1(subCompProp);\n        }\n    }\n    return mergedSet;\n}\n//# sourceMappingURL=concatStyleSets.js.map","// A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -\n// this cache is local to the module closure inside this bundle\nvar packagesCache = {};\n// Cache access to window to avoid IE11 memory leak.\nvar _win = undefined;\ntry {\n    _win = window;\n}\ncatch (e) {\n    /* no-op */\n}\nexport function setVersion(packageName, packageVersion) {\n    if (typeof _win !== 'undefined') {\n        // tslint:disable-next-line:no-any\n        var packages = (_win.__packages__ = _win.__packages__ || {});\n        // We allow either the global packages or local packages caches to invalidate so testing can just clear the global to set this state\n        if (!packages[packageName] || !packagesCache[packageName]) {\n            packagesCache[packageName] = packageVersion;\n            var versions = (packages[packageName] = packages[packageName] || []);\n            versions.push(packageVersion);\n        }\n    }\n}\n//# sourceMappingURL=setVersion.js.map","import { setVersion } from './setVersion';\nexport { setVersion };\nsetVersion('@uifabric/set-version', '6.0.0');\n//# sourceMappingURL=index.js.map","// @uifabric/merge-styles@7.8.3\n// Do not modify this file, the file is generated as part of publish. The checked in version is a placeholder only.\nimport { setVersion } from '@uifabric/set-version';\nsetVersion('@uifabric/merge-styles', '7.8.3');\n//# sourceMappingURL=version.js.map","/**\r\n * Simulated enum for keycodes. These will get inlined by uglify when used much like an enum\r\n *\r\n * @public\r\n * {@docCategory KeyCodes}\r\n */\r\nexport const KeyCodes = {\r\n  backspace: 8 as 8,\r\n  tab: 9 as 9,\r\n  enter: 13 as 13,\r\n  shift: 16 as 16,\r\n  ctrl: 17 as 17,\r\n  alt: 18 as 18,\r\n  pauseBreak: 19 as 19,\r\n  capslock: 20 as 20,\r\n  escape: 27 as 27,\r\n  space: 32 as 32,\r\n  pageUp: 33 as 33,\r\n  pageDown: 34 as 34,\r\n  end: 35 as 35,\r\n  home: 36 as 36,\r\n  left: 37 as 37,\r\n  up: 38 as 38,\r\n  right: 39 as 39,\r\n  down: 40 as 40,\r\n  insert: 45 as 45,\r\n  del: 46 as 46,\r\n  zero: 48 as 48,\r\n  one: 49 as 49,\r\n  two: 50 as 50,\r\n  three: 51 as 51,\r\n  four: 52 as 52,\r\n  five: 53 as 53,\r\n  six: 54 as 54,\r\n  seven: 55 as 55,\r\n  eight: 56 as 56,\r\n  nine: 57 as 57,\r\n  a: 65 as 65,\r\n  b: 66 as 66,\r\n  c: 67 as 67,\r\n  d: 68 as 68,\r\n  e: 69 as 69,\r\n  f: 70 as 70,\r\n  g: 71 as 71,\r\n  h: 72 as 72,\r\n  i: 73 as 73,\r\n  j: 74 as 74,\r\n  k: 75 as 75,\r\n  l: 76 as 76,\r\n  m: 77 as 77,\r\n  n: 78 as 78,\r\n  o: 79 as 79,\r\n  p: 80 as 80,\r\n  q: 81 as 81,\r\n  r: 82 as 82,\r\n  s: 83 as 83,\r\n  t: 84 as 84,\r\n  u: 85 as 85,\r\n  v: 86 as 86,\r\n  w: 87 as 87,\r\n  x: 88 as 88,\r\n  y: 89 as 89,\r\n  z: 90 as 90,\r\n  leftWindow: 91 as 91,\r\n  rightWindow: 92 as 92,\r\n  select: 93 as 93,\r\n  zero_numpad: 96 as 96,\r\n  one_numpad: 97 as 97,\r\n  two_numpad: 98 as 98,\r\n  three_numpad: 99 as 99,\r\n  four_numpad: 100 as 100,\r\n  five_numpad: 101 as 101,\r\n  six_numpad: 102 as 102,\r\n  seven_numpad: 103 as 103,\r\n  eight_numpad: 104 as 104,\r\n  nine_numpad: 105 as 105,\r\n  multiply: 106 as 106,\r\n  add: 107 as 107,\r\n  subtract: 109 as 109,\r\n  decimalPoint: 110 as 110,\r\n  divide: 111 as 111,\r\n  f1: 112 as 112,\r\n  f2: 113 as 113,\r\n  f3: 114 as 114,\r\n  f4: 115 as 115,\r\n  f5: 116 as 116,\r\n  f6: 117 as 117,\r\n  f7: 118 as 118,\r\n  f8: 119 as 119,\r\n  f9: 120 as 120,\r\n  f10: 121 as 121,\r\n  f11: 122 as 122,\r\n  f12: 123 as 123,\r\n  numlock: 144 as 144,\r\n  scrollLock: 145 as 145,\r\n  semicolon: 186 as 186,\r\n  equalSign: 187 as 187,\r\n  comma: 188 as 188,\r\n  dash: 189 as 189,\r\n  period: 190 as 190,\r\n  forwardSlash: 191 as 191,\r\n  graveAccent: 192 as 192,\r\n  openBracket: 219 as 219,\r\n  backSlash: 220 as 220,\r\n  closeBracket: 221 as 221,\r\n  singleQuote: 222 as 222,\r\n}\r\nexport type KeyCodes = number;\r\n","import { KeyCodes } from './KeyCodes'\r\nimport { getDocument } from './dom/getDocument'\r\nimport { getItem, setItem } from './sessionStorage'\r\nimport { setRTL as mergeStylesSetRTL } from '@uifabric/merge-styles'\r\n\r\nconst RTL_LOCAL_STORAGE_KEY = 'isRTL'\r\n\r\n// Default to undefined so that we initialize on first read.\r\nlet _isRTL: boolean | undefined\r\n\r\n/**\r\n * Gets the rtl state of the page (returns true if in rtl.)\r\n */\r\nexport function getRTL (theme: { rtl?: boolean } = {}): boolean {\r\n  if (theme.rtl !== undefined) {\r\n    return theme.rtl\r\n  }\r\n  if (_isRTL === undefined) {\r\n    // Fabric supports persisting the RTL setting between page refreshes via session storage\r\n    let savedRTL = getItem(RTL_LOCAL_STORAGE_KEY)\r\n    if (savedRTL !== null) {\r\n      _isRTL = savedRTL === '1'\r\n      setRTL(_isRTL)\r\n    }\r\n\r\n    let doc = getDocument()\r\n    if (_isRTL === undefined && doc) {\r\n      _isRTL = ((doc.body && doc.body.getAttribute('dir')) || doc.documentElement.getAttribute('dir')) === 'rtl'\r\n      mergeStylesSetRTL(_isRTL)\r\n    }\r\n  }\r\n\r\n  return !!_isRTL\r\n}\r\n\r\n/**\r\n * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)\r\n */\r\nexport function setRTL (isRTL: boolean, persistSetting: boolean = false): void {\r\n  let doc = getDocument()\r\n  if (doc) {\r\n    doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr')\r\n  }\r\n\r\n  if (persistSetting) {\r\n    setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? '1' : '0')\r\n  }\r\n\r\n  _isRTL = isRTL\r\n  mergeStylesSetRTL(_isRTL)\r\n}\r\n\r\n/**\r\n * Returns the given key, but flips right/left arrows if necessary.\r\n */\r\nexport function getRTLSafeKeyCode (key: number): number {\r\n  if (getRTL()) {\r\n    if (key === KeyCodes.left) {\r\n      key = KeyCodes.right\r\n    } else if (key === KeyCodes.right) {\r\n      key = KeyCodes.left\r\n    }\r\n  }\r\n\r\n  return key\r\n}\r\n","/**\r\n * Fetches an item from session storage without throwing an exception\r\n * @param key The key of the item to fetch from session storage\r\n */\r\nexport function getItem (key: string): string | null {\r\n  let result: string | null = null\r\n  try {\r\n    result = window.sessionStorage.getItem(key)\r\n  } catch (e) {\r\n    /* Eat the exception */\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Inserts an item into session storage without throwing an exception\r\n * @param key The key of the item to add to session storage\r\n * @param data The data to put into session storage\r\n */\r\nexport function setItem (key: string, data: string): void {\r\n  try {\r\n    window.sessionStorage.setItem(key, data)\r\n  } catch (e) {\r\n    /* Eat the exception */\r\n  }\r\n}\r\n","import { mergeCssSets, IStyleSet, IProcessedStyleSet, Stylesheet, IStyleFunctionOrObject } from '@uifabric/merge-styles'\r\nimport { getRTL } from './rtl'\r\n\r\nconst MAX_CACHE_COUNT = 50\r\nlet _memoizedClassNames = 0\r\n\r\nconst stylesheet = Stylesheet.getInstance()\r\n\r\nif (stylesheet && stylesheet.onReset) {\r\n  stylesheet.onReset(() => _memoizedClassNames++)\r\n}\r\n\r\n// Note that because of the caching nature within the classNames memoization,\r\n// I've disabled this rule to simply be able to work with any types.\r\n// tslint:disable:no-any\r\n\r\n// This represents a prop we attach to each Map to indicate the cached return value\r\n// associated with the graph node.\r\nconst RetVal = '__retval__'\r\n\r\ninterface IRecursiveMemoNode extends Map<any, IRecursiveMemoNode> {\r\n  [RetVal]?: string;\r\n}\r\n\r\nexport interface IClassNamesFunctionOptions {\r\n  /**\r\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\r\n   */\r\n  disableCaching?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a getClassNames function which calls getStyles given the props, and injects them\r\n * into mergeStyleSets.\r\n *\r\n * Note that the props you pass in on every render should be in the same order and\r\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\r\n * these will cause extra recalcs to occur.\r\n */\r\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSet<TStyleSet>> (\r\n  options: IClassNamesFunctionOptions = {}\r\n): (getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined, styleProps?: TStyleProps) => IProcessedStyleSet<TStyleSet> {\r\n  // We build a trie where each node is a Map. The map entry key represents an argument\r\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\r\n  // property which is used to hold the cached response.\r\n\r\n  // To derive the response, we can simply ensure the arguments are added or already\r\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\r\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\r\n  let map: IRecursiveMemoNode = new Map()\r\n  let resultCount = 0\r\n  let currentMemoizedClassNames = _memoizedClassNames\r\n\r\n  const getClassNames = (\r\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\r\n    styleProps: TStyleProps = {} as TStyleProps\r\n  ): IProcessedStyleSet<TStyleSet> => {\r\n    let current: Map<any, any> = map\r\n    const { theme } = styleProps as any\r\n    const rtl = (theme && theme.rtl) || getRTL()\r\n\r\n    const disableCaching = options.disableCaching\r\n\r\n    // On reset of our stylesheet, reset memoized cache.\r\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\r\n      currentMemoizedClassNames = _memoizedClassNames\r\n      map = new Map()\r\n      resultCount = 0\r\n    }\r\n\r\n    if (!options.disableCaching) {\r\n      current = _traverseMap(map, styleFunctionOrObject as any)\r\n      current = _traverseMap(current, styleProps)\r\n    }\r\n\r\n    if (disableCaching || !(current as any)[RetVal]) {\r\n      if (styleFunctionOrObject === undefined) {\r\n        (current as any)[RetVal] = {} as IProcessedStyleSet<TStyleSet>\r\n      } else {\r\n        (current as any)[RetVal] = mergeCssSets(\r\n          [\r\n            (typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject) as IStyleSet<TStyleSet>,\r\n          ],\r\n          { rtl: !!rtl }\r\n        )\r\n      }\r\n\r\n      if (!disableCaching) {\r\n        resultCount++\r\n      }\r\n    }\r\n\r\n    if (resultCount > MAX_CACHE_COUNT) {\r\n      map.clear()\r\n      resultCount = 0\r\n\r\n      // Mutate the options passed in, that's all we can do.\r\n      options.disableCaching = true\r\n\r\n      // Note: this code is great for debugging problems with styles being recaculated, but commenting it out\r\n      // to avoid confusing consumers.\r\n\r\n      // if (process.env.NODE_ENV !== 'production') {\r\n      //  console.log('Styles are being recalculated far too frequently. Something is mutating the class over and over.');\r\n      //  // tslint:disable-next-line:no-console\r\n      //  console.trace();\r\n      // }\r\n    }\r\n\r\n    // Note: the RetVal is an attached property on the Map; not a key in the Map. We use this attached property to\r\n    // cache the return value for this branch of the graph.\r\n    return (current as any)[RetVal]\r\n  }\r\n\r\n  return getClassNames\r\n}\r\n\r\nfunction _traverseEdge (current: Map<any, any>, value: any): Map<any, any> {\r\n  value = _normalizeValue(value)\r\n\r\n  if (!current.has(value)) {\r\n    current.set(value, new Map<any, any>())\r\n  }\r\n\r\n  return current.get(value)\r\n}\r\n\r\nfunction _traverseMap (current: Map<any, any>, inputs: any[] | Object): Map<any, any> {\r\n  // The styled helper will generate the styles function and will attach the cached\r\n  // inputs (consisting of the default styles, customzied styles, and user provided styles.)\r\n  // These should be used as cache keys for deriving the memoized value.\r\n  if (typeof inputs === 'function' && (inputs as any).__cachedInputs__) {\r\n    for (const input of (inputs as any).__cachedInputs__) {\r\n      current = _traverseEdge(current, input)\r\n    }\r\n  } else if (typeof inputs === 'object') {\r\n    for (const propName in inputs) {\r\n      if (inputs.hasOwnProperty(propName)) {\r\n        current = _traverseEdge(current, (inputs as any)[propName])\r\n      }\r\n    }\r\n  }\r\n\r\n  return current\r\n}\r\n\r\nfunction _normalizeValue (value: any): string {\r\n  switch (value) {\r\n    case undefined:\r\n      return '__undefined__'\r\n    case null:\r\n      return '__null__'\r\n    default:\r\n      return value\r\n  }\r\n}\r\n","import { getWindow } from './dom/getWindow'\r\n\r\n/**\r\n * Storing global state in local module variables has issues when more than one copy\r\n * if the module gets loaded on the page (due to a bundling error or simply by consuming\r\n * a prebundled script.)\r\n *\r\n * This file contains helpers to deal with the getting and setting local state, and allows\r\n * callers to get called back when it mutates.\r\n */\r\n\r\n// tslint:disable:no-any\r\n\r\nconst GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__'\r\nconst CALLBACK_STATE_PROP_NAME = '__callbacks__'\r\n\r\nlet _counter = 0\r\n\r\n/**\r\n * Change description used for change callbacks in GlobalSettings.\r\n *\r\n * @public\r\n * {@docCategory IChangeDescription}\r\n */\r\nexport interface IChangeDescription {\r\n  key: string;\r\n  // tslint:disable-next-line:no-any\r\n  oldValue: any;\r\n  // tslint:disable-next-line:no-any\r\n  value: any;\r\n}\r\n\r\n/**\r\n * Change event callback.\r\n *\r\n * @public\r\n * {@docCategory IChangeEventCallback}\r\n */\r\nexport interface IChangeEventCallback {\r\n  __id__?: string;\r\n  (changeDescription?: IChangeDescription): void;\r\n}\r\n\r\n/**\r\n * Global settings helper, which stores settings in the global (window) namespace.\r\n * If window is not provided, it will store settings in module scope. Provides a\r\n * way to observe changes as well when their values change.\r\n *\r\n * @public\r\n * {@docCategory GlobalSettings}\r\n */\r\nexport class GlobalSettings {\r\n  public static getValue<T> (key: string, defaultValue?: T | (() => T)): T {\r\n    const globalSettings = _getGlobalSettings()\r\n\r\n    if (globalSettings[key] === undefined) {\r\n      globalSettings[key] = typeof defaultValue === 'function' ? (defaultValue as Function)() : defaultValue\r\n    }\r\n\r\n    return globalSettings[key]\r\n  }\r\n\r\n  public static setValue<T> (key: string, value: T): T {\r\n    const globalSettings = _getGlobalSettings()\r\n    const callbacks = globalSettings[CALLBACK_STATE_PROP_NAME]\r\n    let oldValue = globalSettings[key]\r\n\r\n    if (value !== oldValue) {\r\n      globalSettings[key] = value\r\n\r\n      let changeDescription = {\r\n        oldValue,\r\n        value,\r\n        key,\r\n      }\r\n\r\n      for (let id in callbacks) {\r\n        if (callbacks.hasOwnProperty(id)) {\r\n          callbacks[id](changeDescription)\r\n        }\r\n      }\r\n    }\r\n\r\n    return value\r\n  }\r\n\r\n  public static addChangeListener (cb: IChangeEventCallback): void {\r\n    // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.\r\n    // (It's faster to delete a key than it is to look up the index of an object and splice an array.)\r\n    let id = cb.__id__\r\n    const callbacks = _getCallbacks()\r\n\r\n    if (!id) {\r\n      id = cb.__id__ = String(_counter++)\r\n    }\r\n\r\n    callbacks[id] = cb\r\n  }\r\n\r\n  public static removeChangeListener (cb: IChangeEventCallback): void {\r\n    const callbacks = _getCallbacks()\r\n    delete callbacks[cb.__id__ as string]\r\n  }\r\n}\r\n\r\nfunction _getGlobalSettings (): { [key: string]: any } {\r\n  const win = getWindow()\r\n  const globalObj: { [key: string]: any } = win || {}\r\n\r\n  if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {\r\n    globalObj[GLOBAL_SETTINGS_PROP_NAME] = {\r\n      [CALLBACK_STATE_PROP_NAME]: {},\r\n    }\r\n  }\r\n\r\n  return globalObj[GLOBAL_SETTINGS_PROP_NAME]\r\n}\r\n\r\nfunction _getCallbacks (): { [key: string]: () => void } {\r\n  const globalSettings = _getGlobalSettings()\r\n  return globalSettings[CALLBACK_STATE_PROP_NAME]\r\n}\r\n","\r\nimport { GlobalSettings } from '../GlobalSettings'\r\n\r\n// tslint:disable-next-line:no-any\r\nexport type ISettings = { [key: string]: any };\r\nexport type ISettingsFunction = (settings: ISettings) => ISettings;\r\n\r\n/**\r\n * @deprecated Use ISettings.\r\n */\r\nexport type Settings = ISettings;\r\n\r\n/**\r\n * @deprecated Use ISettingsFunction.\r\n */\r\nexport type SettingsFunction = ISettingsFunction;\r\n\r\nexport interface ICustomizations {\r\n  settings: ISettings;\r\n  scopedSettings: { [key: string]: ISettings };\r\n  inCustomizerContext?: boolean;\r\n}\r\n\r\nconst CustomizationsGlobalKey = 'customizations'\r\nconst NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false }\r\n\r\nlet _allSettings = GlobalSettings.getValue<ICustomizations>(CustomizationsGlobalKey, {\r\n  settings: {},\r\n  scopedSettings: {},\r\n  inCustomizerContext: false,\r\n})\r\n\r\nlet _events: (() => void)[] = []\r\n\r\nexport class Customizations {\r\n  public static reset (): void {\r\n    _allSettings.settings = {}\r\n    _allSettings.scopedSettings = {}\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public static applySettings (settings: ISettings): void {\r\n    _allSettings.settings = { ..._allSettings.settings, ...settings }\r\n    Customizations._raiseChange()\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public static applyScopedSettings (scopeName: string, settings: ISettings): void {\r\n    _allSettings.scopedSettings[scopeName] = { ..._allSettings.scopedSettings[scopeName], ...settings }\r\n    Customizations._raiseChange()\r\n  }\r\n\r\n  public static getSettings (\r\n    properties: string[],\r\n    scopeName?: string,\r\n    localSettings: ICustomizations = NO_CUSTOMIZATIONS\r\n    // tslint:disable-next-line:no-any\r\n  ): any {\r\n    // tslint:disable-next-line:no-any\r\n    const settings: ISettings = {}\r\n    const localScopedSettings = (scopeName && localSettings.scopedSettings[scopeName]) || {}\r\n    const globalScopedSettings = (scopeName && _allSettings.scopedSettings[scopeName]) || {}\r\n\r\n    for (let property of properties) {\r\n      settings[property] =\r\n        localScopedSettings[property] ||\r\n        localSettings.settings[property] ||\r\n        globalScopedSettings[property] ||\r\n        _allSettings.settings[property]\r\n    }\r\n\r\n    return settings\r\n  }\r\n\r\n  public static observe (onChange: () => void): void {\r\n    _events.push(onChange)\r\n  }\r\n\r\n  public static unobserve (onChange: () => void): void {\r\n    _events = _events.filter((cb: () => void) => cb !== onChange)\r\n  }\r\n\r\n  private static _raiseChange (): void {\r\n    _events.forEach((cb: () => void) => cb())\r\n  }\r\n}\r\n","import { ISettings, ISettingsFunction } from './Customizations'\r\n\r\n/**\r\n * Merge new and old settings, giving priority to new settings.\r\n * New settings is optional in which case oldSettings is returned as-is.\r\n * @param oldSettings - Old settings to fall back to.\r\n * @param newSettings - New settings that will be merged over oldSettings.\r\n * @returns Merged settings.\r\n */\r\nexport function mergeSettings (oldSettings: ISettings = {}, newSettings?: ISettings | ISettingsFunction): ISettings {\r\n  const mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings)\r\n\r\n  return mergeSettingsWith(oldSettings)\r\n}\r\n\r\nexport function mergeScopedSettings (oldSettings: ISettings = {}, newSettings?: ISettings | ISettingsFunction): ISettings {\r\n  const mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings)\r\n\r\n  return mergeSettingsWith(oldSettings)\r\n}\r\n\r\nfunction _isSettingsFunction (settings?: ISettings | ISettingsFunction): settings is ISettingsFunction {\r\n  return typeof settings === 'function'\r\n}\r\n\r\nfunction _settingsMergeWith (newSettings?: object): (settings: ISettings) => ISettings {\r\n  return (settings: ISettings) => (newSettings ? { ...settings, ...newSettings } : settings)\r\n}\r\n\r\nfunction _scopedSettingsMergeWith (scopedSettingsFromProps: ISettings = {}): (scopedSettings: ISettings) => ISettings {\r\n  return (oldScopedSettings: ISettings): ISettings => {\r\n    const newScopedSettings: ISettings = { ...oldScopedSettings }\r\n\r\n    for (let scopeName in scopedSettingsFromProps) {\r\n      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {\r\n        newScopedSettings[scopeName] = { ...oldScopedSettings[scopeName], ...scopedSettingsFromProps[scopeName] }\r\n      }\r\n    }\r\n\r\n    return newScopedSettings\r\n  }\r\n}\r\n","/**\r\n * Helper to find the index of an item within an array, using a callback to\r\n * determine the match.\r\n *\r\n * @public\r\n * @param array - Array to search.\r\n * @param cb - Callback which returns true on matches.\r\n */\r\nexport function findIndex<T> (array: T[], cb: (item: T, index: number) => boolean): number {\r\n  let index = -1\r\n\r\n  // eslint-disable-next-line no-unmodified-loop-condition\r\n  for (let i = 0; array && i < array.length; i++) {\r\n    if (cb(array[i], i)) {\r\n      index = i\r\n      break\r\n    }\r\n  }\r\n\r\n  return index\r\n}\r\n\r\n/**\r\n * Helper to find the first item within an array that satisfies the callback.\r\n * @param array - Array to search\r\n * @param cb - Callback which returns true on matches\r\n */\r\nexport function find<T> (array: T[], cb: (item: T, index: number) => boolean): T | undefined {\r\n  let index = findIndex(array, cb)\r\n\r\n  if (index < 0) {\r\n    return undefined\r\n  }\r\n\r\n  return array[index]\r\n}\r\n\r\n/**\r\n * Creates an array of a given size and helper method to populate.\r\n *\r\n * @public\r\n * @param size - Size of array.\r\n * @param getItem - Callback to populate given cell index.\r\n */\r\nexport function createArray<T> (size: number, getItem: (index: number) => T): T[] {\r\n  let array: T[] = []\r\n\r\n  for (let i = 0; i < size; i++) {\r\n    array.push(getItem(i))\r\n  }\r\n\r\n  return array\r\n}\r\n\r\n/**\r\n * Convert the given array to a matrix with columnCount number\r\n * of columns.\r\n *\r\n * @public\r\n * @param items - The array to convert\r\n * @param columnCount - The number of columns for the resulting matrix\r\n * @returns A matrix of items\r\n */\r\nexport function toMatrix<T> (items: T[], columnCount: number): T[][] {\r\n  return items.reduce(\r\n    (rows: T[][], currentValue: T, index: number) => {\r\n      if (index % columnCount === 0) {\r\n        rows.push([currentValue])\r\n      } else {\r\n        rows[rows.length - 1].push(currentValue)\r\n      }\r\n      return rows\r\n    },\r\n    [] as T[][]\r\n  )\r\n}\r\n\r\n/**\r\n * Given an array, it returns a new array that does not contain the item at the given index.\r\n * @param array - The array to operate on\r\n * @param index - The index of the element to remove\r\n */\r\nexport function removeIndex<T> (array: T[], index: number): T[] {\r\n  return array.filter((_: T, i: number) => index !== i)\r\n}\r\n\r\n/**\r\n * Given an array, this function returns a new array where the element at a given index has been replaced.\r\n * @param array - The array to operate on\r\n * @param newElement - The element that will be placed in the new array\r\n * @param index - The index of the element that should be replaced\r\n */\r\nexport function replaceElement<T> (array: T[], newElement: T, index: number): T[] {\r\n  const copy = array.slice()\r\n  copy[index] = newElement\r\n  return copy\r\n}\r\n\r\n/**\r\n * Given an array, this function returns a new array where an element has been inserted at the given index.\r\n * @param array - The array to operate on\r\n * @param index - The index where an element should be inserted\r\n * @param itemToAdd - The element to insert\r\n */\r\nexport function addElementAtIndex<T> (array: T[], index: number, itemToAdd: T): T[] {\r\n  const copy = array.slice()\r\n  copy.splice(index, 0, itemToAdd)\r\n  return copy\r\n}\r\n\r\n/**\r\n * Given an array where each element is of type T or T[], flatten it into an array of T\r\n * @param array - The array where each element can optionally also be an array\r\n */\r\nexport function flatten<T> (array: (T | T[])[]): T[] {\r\n  let result: T[] = []\r\n  array.forEach((item: T | T[]): T[] => (result = result.concat(item)))\r\n  return result\r\n}\r\n\r\n/**\r\n * Returns a boolean indicating if the two given arrays are equal in length and values.\r\n *\r\n * @param array1 - First array to compare\r\n * @param array2 - Second array to compare\r\n * @returns True if the arrays are the same length and have the same values in the same positions, false otherwise.\r\n */\r\nexport function arraysEqual<T> (array1: T[], array2: T[]): boolean {\r\n  if (array1.length !== array2.length) {\r\n    return false\r\n  }\r\n  for (let i = 0; i < array1.length; i++) {\r\n    if (array1[i] !== array2[i]) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n","import { KeyCodes } from './KeyCodes'\r\n\r\nconst DirectionalKeyCodes: { [key: number]: number } = {\r\n  [KeyCodes.up]: 1,\r\n  [KeyCodes.down]: 1,\r\n  [KeyCodes.left]: 1,\r\n  [KeyCodes.right]: 1,\r\n  [KeyCodes.home]: 1,\r\n  [KeyCodes.end]: 1,\r\n  [KeyCodes.tab]: 1,\r\n  [KeyCodes.pageUp]: 1,\r\n  [KeyCodes.pageDown]: 1,\r\n}\r\n\r\n/**\r\n * Returns true if the keycode is a directional keyboard key.\r\n */\r\nexport function isDirectionalKeyCode (which: number): boolean {\r\n  return !!DirectionalKeyCodes[which]\r\n}\r\n\r\n/**\r\n * Adds a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible.\r\n * This can be used to add global shortcut keys that directionally move from section to section within\r\n * an app or between focus trap zones.\r\n */\r\nexport function addDirectionalKeyCode (which: number): void {\r\n  DirectionalKeyCodes[which] = 1\r\n}\r\n","import { getWindow } from './dom/getWindow'\r\nimport { isDirectionalKeyCode } from './keyboard'\r\n\r\nexport const IsFocusVisibleClassName = 'ms-Fabric--isFocusVisible'\r\n\r\n/**\r\n * Initializes the logic which:\r\n *\r\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\r\n *    so it's safe to call this method multiple times.)\r\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\r\n *    to the document body.\r\n * 3. When the user clicks a mouse button, we remove the classname if it exists.\r\n *\r\n * This logic allows components on the page to conditionally render focus treatments only\r\n * if the global classname exists, which simplifies logic overall.\r\n *\r\n * @param window - the window used to add the event listeners\r\n */\r\nexport function initializeFocusRects (window?: Window): void {\r\n  const win = (window || getWindow()) as Window & { __hasInitializeFocusRects__: boolean }\r\n\r\n  if (win && !win.__hasInitializeFocusRects__) {\r\n    win.__hasInitializeFocusRects__ = true\r\n    win.addEventListener('mousedown', _onMouseDown, true)\r\n    win.addEventListener('keydown', _onKeyDown as () => void, true)\r\n  }\r\n}\r\n\r\nfunction _onMouseDown (ev: MouseEvent): void {\r\n  const win = getWindow(ev.target as Element)\r\n\r\n  if (win) {\r\n    const { classList } = win.document.body\r\n\r\n    if (classList.contains(IsFocusVisibleClassName)) {\r\n      classList.remove(IsFocusVisibleClassName)\r\n    }\r\n  }\r\n}\r\n\r\nfunction _onKeyDown (ev: KeyboardEvent): void {\r\n  const win = getWindow(ev.target as Element)\r\n\r\n  if (win) {\r\n    const { classList } = win.document.body\r\n\r\n    if (isDirectionalKeyCode(ev.which) && !classList.contains(IsFocusVisibleClassName)) {\r\n      classList.add(IsFocusVisibleClassName)\r\n    }\r\n  }\r\n}\r\n","import { Stylesheet } from '@uifabric/merge-styles'\r\n\r\nconst stylesheet = Stylesheet.getInstance()\r\n\r\nif (stylesheet && stylesheet.onReset) {\r\n  Stylesheet.getInstance().onReset(resetMemoizations)\r\n}\r\n\r\n// tslint:disable:no-any\r\ndeclare class WeakMap {\r\n  public get(key: any): any;\r\n  public set(key: any, value: any): void;\r\n  public has(key: any): boolean;\r\n}\r\n\r\nlet _resetCounter = 0\r\nconst _emptyObject = { empty: true }\r\nconst _dictionary: any = {}\r\nlet _weakMap = typeof WeakMap === 'undefined' ? null : WeakMap\r\n\r\ninterface IMemoizeNode {\r\n  map: WeakMap | null;\r\n  value?: any;\r\n}\r\n\r\n/**\r\n *  Test utility for providing a custom weakmap.\r\n *\r\n * @internal\r\n * */\r\nexport function setMemoizeWeakMap (weakMap: any): void {\r\n  _weakMap = weakMap\r\n}\r\n\r\n/**\r\n * Reset memoizations.\r\n */\r\nexport function resetMemoizations (): void {\r\n  _resetCounter++\r\n}\r\n\r\n/**\r\n * Memoize decorator to be used on class methods. WARNING: the `this` reference\r\n * will be inaccessible within a memoized method, given that a cached method's `this`\r\n * would not be instance-specific.\r\n *\r\n * @public\r\n */\r\nexport function memoize<T extends Function> (\r\n  target: any,\r\n  key: string,\r\n  descriptor: TypedPropertyDescriptor<T>\r\n): {\r\n    configurable: boolean;\r\n    get(): T;\r\n  } {\r\n  // We bind to \"null\" to prevent people from inadvertently pulling values from \"this\",\r\n  // rather than passing them in as input values which can be memoized.\r\n  let fn = memoizeFunction(descriptor.value && descriptor.value.bind(null))\r\n\r\n  return {\r\n    configurable: true,\r\n    get (): T {\r\n      return fn\r\n    },\r\n  }\r\n}\r\n\r\n/**\r\n * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.\r\n * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise\r\n * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in\r\n * undefined for a value and relying on a default function will execute it the first time, but will not\r\n * re-evaluate subsequent times which may have been unexpected.\r\n *\r\n * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is\r\n * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard\r\n * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.\r\n *\r\n * @public\r\n * @param cb - The function to memoize.\r\n * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.\r\n * @returns A memoized version of the function.\r\n */\r\nexport function memoizeFunction<T extends (...args: any[]) => RET_TYPE, RET_TYPE>(cb: T, maxCacheSize: number = 100): T {\r\n  // Avoid breaking scenarios which don't have weak map.\r\n  if (!_weakMap) {\r\n    return cb\r\n  }\r\n\r\n  let rootNode: any\r\n  let cacheSize = 0\r\n  let localResetCounter = _resetCounter\r\n\r\n  // tslint:disable-next-line:no-function-expression\r\n  return function memoizedFunction (...args: any[]): RET_TYPE {\r\n    let currentNode: any = rootNode\r\n\r\n    if (rootNode === undefined || localResetCounter !== _resetCounter || (maxCacheSize > 0 && cacheSize > maxCacheSize)) {\r\n      rootNode = _createNode()\r\n      cacheSize = 0\r\n      localResetCounter = _resetCounter\r\n    }\r\n\r\n    currentNode = rootNode\r\n\r\n    // Traverse the tree until we find the match.\r\n    for (let i = 0; i < args.length; i++) {\r\n      let arg = _normalizeArg(args[i])\r\n\r\n      if (!currentNode.map.has(arg)) {\r\n        currentNode.map.set(arg, _createNode())\r\n      }\r\n\r\n      currentNode = currentNode.map.get(arg)\r\n    }\r\n\r\n    if (!currentNode.hasOwnProperty('value')) {\r\n      // eslint-disable-next-line standard/no-callback-literal\r\n      currentNode.value = cb(...args)\r\n      cacheSize++\r\n    }\r\n\r\n    return currentNode.value\r\n  } as any\r\n}\r\n\r\nfunction _normalizeArg(val: null | undefined): { empty: boolean } | any;\r\nfunction _normalizeArg(val: object): any;\r\nfunction _normalizeArg (val: any): any {\r\n  if (!val) {\r\n    return _emptyObject\r\n  } else if (typeof val === 'object' || typeof val === 'function') {\r\n    return val\r\n  } else if (!_dictionary[val]) {\r\n    _dictionary[val] = { val }\r\n  }\r\n\r\n  return _dictionary[val]\r\n}\r\n\r\nfunction _createNode (): IMemoizeNode {\r\n  return {\r\n    map: _weakMap ? new _weakMap() : null,\r\n  }\r\n}\r\n","/**\r\n * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged\r\n * together in the order provided. If an object creates a circular reference, it will assign the\r\n * original reference.\r\n */\r\nexport function merge<T = {}> (target: Partial<T>, ...args: (Partial<T> | null | undefined | false)[]): T {\r\n  for (const arg of args) {\r\n    _merge(target || {}, arg as Partial<T>)\r\n  }\r\n\r\n  return target as T\r\n}\r\n\r\n/**\r\n * The _merge helper iterates through all props on source and assigns them to target.\r\n * When the value is an object, we will create a deep clone of the object. However if\r\n * there is a circular reference, the value will not be deep cloned and will persist\r\n * the reference.\r\n */\r\n// tslint:disable-next-line:no-any\r\nfunction _merge<T extends Object> (target: T, source: T, circularReferences: any[] = []): T {\r\n  circularReferences.push(source)\r\n\r\n  for (let name in source) {\r\n    if (source.hasOwnProperty(name)) {\r\n      const value: T[Extract<keyof T, string>] = source[name]\r\n      if (typeof value === 'object') {\r\n        const isCircularReference = circularReferences.indexOf(value) > -1\r\n        target[name] = (isCircularReference ? value : _merge(target[name] || {}, value, circularReferences)) as T[Extract<keyof T, string>]\r\n      } else {\r\n        target[name] = value\r\n      }\r\n    }\r\n  }\r\n\r\n  circularReferences.pop()\r\n\r\n  return target\r\n}\r\n","import { getWindow } from './dom/getWindow'\r\n\r\n// Initialize global window id.\r\nconst CURRENT_ID_PROPERTY = '__currentId__'\r\nconst DEFAULT_ID_STRING = 'id__'\r\n\r\n// tslint:disable-next-line:no-any\r\nlet _global: any = getWindow() || {}\r\n\r\nif (_global[CURRENT_ID_PROPERTY] === undefined) {\r\n  _global[CURRENT_ID_PROPERTY] = 0\r\n}\r\n\r\n/**\r\n * Generates a unique id in the global scope (this spans across duplicate copies of the same library.)\r\n *\r\n * @public\r\n */\r\nexport function getId (prefix?: string): string {\r\n  let index = _global[CURRENT_ID_PROPERTY]++\r\n\r\n  return (prefix || DEFAULT_ID_STRING) + index\r\n}\r\n\r\n/**\r\n * Resets id counter to an (optional) number.\r\n *\r\n * @public\r\n */\r\nexport function resetIds (counter: number = 0): void {\r\n  _global[CURRENT_ID_PROPERTY] = counter\r\n}\r\n","import { Stylesheet } from '@uifabric/merge-styles'\r\nimport { getId, resetIds } from './getId'\r\n\r\nexport { getId, resetIds }\r\n\r\n// tslint:disable-next-line:no-any\r\nfunction checkProperties (a: any, b: any): boolean {\r\n  for (let propName in a) {\r\n    if (a.hasOwnProperty(propName)) {\r\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Compares a to b and b to a.\r\n *\r\n * @public\r\n */\r\nexport function shallowCompare<TA, TB> (a: TA, b: TB): boolean {\r\n  return checkProperties(a, b) && checkProperties(b, a)\r\n}\r\n\r\n/**\r\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\r\n * objects as arguments and they will be merged sequentially into the target. Note that this will\r\n * shallow merge; it will not create new cloned values for target members.\r\n *\r\n * @public\r\n * @param target - Target object to merge following object arguments into.\r\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\r\n * @returns Resulting merged target.\r\n */\r\n// tslint:disable-next-line:no-any\r\nexport function assign (target: any, ...args: any[]): any {\r\n  // @ts-ignore\r\n  return filteredAssign.apply(this, [null, target].concat(args))\r\n}\r\n\r\n/**\r\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\r\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\r\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\r\n * values for target members.\r\n *\r\n * @public\r\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\r\n * @param target - Target object to merge following object arguments into.\r\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\r\n * @returns Resulting merged target.\r\n */\r\n// tslint:disable-next-line:no-any\r\nexport function filteredAssign (isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any {\r\n  target = target || {}\r\n\r\n  for (let sourceObject of args) {\r\n    if (sourceObject) {\r\n      for (let propName in sourceObject) {\r\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\r\n          target[propName] = sourceObject[propName]\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\n// Configure ids to reset on stylesheet resets.\r\nconst stylesheet = Stylesheet.getInstance()\r\n\r\nif (stylesheet && stylesheet.onReset) {\r\n  stylesheet.onReset(resetIds)\r\n}\r\n\r\n/* Takes an enum and iterates over each value of the enum (as a string), running the callback on each, returning a mapped array.\r\n * The callback takes as a first parameter the string that represents the name of the entry, and the second parameter is the\r\n * value of that entry, which is the value you'd normally use when using the enum (usually a number).\r\n * */\r\nexport function mapEnumByName<T> (\r\n  // tslint:disable-next-line:no-any\r\n  theEnum: any,\r\n  callback: (name?: string, value?: string | number) => T | undefined\r\n): (T | undefined)[] | undefined {\r\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\r\n  return Object.keys(theEnum)\r\n    .map<T | undefined>((p: string | number) => {\r\n    // map on each property name as a string\r\n    if (String(Number(p)) !== p) {\r\n      // if the property is not just a number (because enums in TypeScript will map both ways)\r\n      return callback(p as string, theEnum[p])\r\n    }\r\n  })\r\n    .filter((v: T | undefined) => !!v) // only return elements with values\r\n}\r\n\r\n/**\r\n * Get all values in an object dictionary\r\n *\r\n * @param obj - The dictionary to get values for\r\n */\r\n// tslint:disable-next-line:no-any\r\nexport function values<T> (obj: any): T[] {\r\n  return Object.keys(obj).reduce((arr: T[], key: string): T[] => {\r\n    arr.push(obj[key])\r\n    return arr\r\n  }, [])\r\n}\r\n","import { filteredAssign } from './object'\r\n\r\n/**\r\n * An array of events that are allowed on every html element type.\r\n *\r\n * @public\r\n */\r\nexport const baseElementEvents = [\r\n  'onCopy',\r\n  'onCut',\r\n  'onPaste',\r\n  'onCompositionEnd',\r\n  'onCompositionStart',\r\n  'onCompositionUpdate',\r\n  'onFocus',\r\n  'onFocusCapture',\r\n  'onBlur',\r\n  'onBlurCapture',\r\n  'onChange',\r\n  'onInput',\r\n  'onSubmit',\r\n  'onLoad',\r\n  'onError',\r\n  'onKeyDown',\r\n  'onKeyDownCapture',\r\n  'onKeyPress',\r\n  'onKeyUp',\r\n  'onAbort',\r\n  'onCanPlay',\r\n  'onCanPlayThrough',\r\n  'onDurationChange',\r\n  'onEmptied',\r\n  'onEncrypted',\r\n  'onEnded',\r\n  'onLoadedData',\r\n  'onLoadedMetadata',\r\n  'onLoadStart',\r\n  'onPause',\r\n  'onPlay',\r\n  'onPlaying',\r\n  'onProgress',\r\n  'onRateChange',\r\n  'onSeeked',\r\n  'onSeeking',\r\n  'onStalled',\r\n  'onSuspend',\r\n  'onTimeUpdate',\r\n  'onVolumeChange',\r\n  'onWaiting',\r\n  'onClick',\r\n  'onClickCapture',\r\n  'onContextMenu',\r\n  'onDoubleClick',\r\n  'onDrag',\r\n  'onDragEnd',\r\n  'onDragEnter',\r\n  'onDragExit',\r\n  'onDragLeave',\r\n  'onDragOver',\r\n  'onDragStart',\r\n  'onDrop',\r\n  'onMouseDown',\r\n  'onMouseDownCapture',\r\n  'onMouseEnter',\r\n  'onMouseLeave',\r\n  'onMouseMove',\r\n  'onMouseOut',\r\n  'onMouseOver',\r\n  'onMouseUp',\r\n  'onMouseUpCapture',\r\n  'onSelect',\r\n  'onTouchCancel',\r\n  'onTouchEnd',\r\n  'onTouchMove',\r\n  'onTouchStart',\r\n  'onScroll',\r\n  'onWheel',\r\n  'onPointerCancel',\r\n  'onPointerDown',\r\n  'onPointerEnter',\r\n  'onPointerLeave',\r\n  'onPointerMove',\r\n  'onPointerOut',\r\n  'onPointerOver',\r\n  'onPointerUp',\r\n  'onGotPointerCapture',\r\n  'onLostPointerCapture',\r\n]\r\n\r\n/**\r\n * An array of element attributes which are allowed on every html element type.\r\n *\r\n * @public\r\n */\r\nexport const baseElementProperties = [\r\n  'accessKey', // global\r\n  'children', // global\r\n  'className', // global\r\n  'contentEditable', // global\r\n  'dir', // global\r\n  'draggable', // global\r\n  'hidden', // global\r\n  'htmlFor', // global\r\n  'id', // global\r\n  'lang', // global\r\n  'role', // global\r\n  'style', // global\r\n  'tabIndex', // global\r\n  'title', // global\r\n  'translate', // global\r\n  'spellCheck', // global\r\n  'name', // global\r\n]\r\n\r\n/**\r\n * An array of HTML element properties and events.\r\n *\r\n * @public\r\n */\r\nexport const htmlElementProperties = baseElementProperties.concat(baseElementEvents)\r\n\r\n/**\r\n * An array of LABEL tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const labelProperties = htmlElementProperties.concat([\r\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\r\n])\r\n\r\n/**\r\n * An array of AUDIO tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const audioProperties = htmlElementProperties.concat([\r\n  'height', // canvas, embed, iframe, img, input, object, video\r\n  'loop', // audio, video\r\n  'muted', // audio, video\r\n  'preload', // audio, video\r\n  'src', // audio, embed, iframe, img, input, script, source, track, video\r\n  'width', // canvas, embed, iframe, img, input, object, video\r\n])\r\n\r\n/**\r\n * An array of VIDEO tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const videoProperties = audioProperties.concat([\r\n  'poster', // video\r\n])\r\n\r\n/**\r\n * An array of OL tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const olProperties = htmlElementProperties.concat([\r\n  'start', // ol\r\n])\r\n\r\n/**\r\n * An array of LI tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const liProperties = htmlElementProperties.concat([\r\n  'value', // button, input, li, option, meter, progress, param\r\n])\r\n\r\n/**\r\n * An array of A tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const anchorProperties = htmlElementProperties.concat([\r\n  'download', // a, area\r\n  'href', // a, area, base, link\r\n  'hrefLang', // a, area, link\r\n  'media', // a, area, link, source, style\r\n  'rel', // a, area, link\r\n  'target', // a, area, base, form\r\n  'type', // a, button, input, link, menu, object, script, source, style\r\n])\r\n\r\n/**\r\n * An array of BUTTON tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const buttonProperties = htmlElementProperties.concat([\r\n  'autoFocus', // button, input, select, textarea\r\n  'disabled', // button, fieldset, input, optgroup, option, select, textarea\r\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\r\n  'formAction', // input, button\r\n  'formEncType', // input, button\r\n  'formMethod', // input, button\r\n  'formNoValidate', // input, button\r\n  'formTarget', // input, button\r\n  'type', // a, button, input, link, menu, object, script, source, style\r\n  'value', // button, input, li, option, meter, progress, param,\r\n])\r\n\r\n/**\r\n * An array of INPUT tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const inputProperties = buttonProperties.concat([\r\n  'accept', // input\r\n  'alt', // area, img, input\r\n  'autoComplete', // form, input\r\n  'checked', // input\r\n  'dirname', // input, textarea\r\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\r\n  'height', // canvas, embed, iframe, img, input, object, video\r\n  'inputMode', // input\r\n  'list', // input\r\n  'max', // input, meter\r\n  'maxLength', // input, textarea\r\n  'min', // input, meter\r\n  'multiple', // input, select\r\n  'pattern', // input\r\n  'placeholder', // input, textarea\r\n  'readOnly', // input, textarea\r\n  'required', // input, select, textarea\r\n  'src', // audio, embed, iframe, img, input, script, source, track, video\r\n  'step', // input\r\n  'size', // input\r\n  'type', // a, button, input, link, menu, object, script, source, style\r\n  'value', // button, input, li, option, meter, progress, param\r\n  'width', // canvas, embed, iframe, img, input, object, video\r\n])\r\n\r\n/**\r\n * An array of TEXTAREA tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const textAreaProperties = buttonProperties.concat([\r\n  'cols', // textarea\r\n  'dirname', // input, textarea\r\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\r\n  'maxLength', // input, textarea\r\n  'placeholder', // input, textarea\r\n  'readOnly', // input, textarea\r\n  'required', // input, select, textarea\r\n  'rows', // textarea\r\n  'wrap', // textarea\r\n])\r\n\r\n/**\r\n * An array of SELECT tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const selectProperties = buttonProperties.concat([\r\n  'form', // button, fieldset, input, label, meter, object, output, select, textarea\r\n  'multiple', // input, select\r\n  'required', // input, select, textarea\r\n])\r\n\r\nexport const optionProperties = htmlElementProperties.concat([\r\n  'selected', // option\r\n  'value', // button, input, li, option, meter, progress, param\r\n])\r\n\r\n/**\r\n * An array of TABLE tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const tableProperties = htmlElementProperties.concat([\r\n  'cellPadding', // table\r\n  'cellSpacing', // table\r\n])\r\n\r\n/**\r\n * An array of TR tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const trProperties = htmlElementProperties\r\n\r\n/**\r\n * An array of TH tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const thProperties = htmlElementProperties.concat([\r\n  'rowSpan', // td, th\r\n  'scope', // th\r\n])\r\n\r\n/**\r\n * An array of TD tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const tdProperties = htmlElementProperties.concat([\r\n  'colSpan', // td\r\n  'headers', // td\r\n  'rowSpan', // td, th\r\n  'scope', // th\r\n])\r\n\r\nexport const colGroupProperties = htmlElementProperties.concat([\r\n  'span', // col, colgroup\r\n])\r\n\r\nexport const colProperties = htmlElementProperties.concat([\r\n  'span', // col, colgroup\r\n])\r\n\r\n/**\r\n * An array of FORM tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const formProperties = htmlElementProperties.concat([\r\n  'acceptCharset', // form\r\n  'action', // form\r\n  'encType', // form\r\n  'encType', // form\r\n  'method', // form\r\n  'noValidate', // form\r\n  'target', // form\r\n])\r\n\r\n/**\r\n * An array of IFRAME tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const iframeProperties = htmlElementProperties.concat([\r\n  'allow', // iframe\r\n  'allowFullScreen', // iframe\r\n  'allowPaymentRequest', // iframe\r\n  'allowTransparency', // iframe\r\n  'csp', // iframe\r\n  'height', // canvas, embed, iframe, img, input, object, video\r\n  'importance', // iframe\r\n  'referrerPolicy', // iframe\r\n  'sandbox', // iframe\r\n  'src', // audio, embed, iframe, img, input, script, source, track, video\r\n  'srcDoc', // iframe\r\n  'width', // canvas, embed, iframe, img, input, object, video,\r\n])\r\n\r\n/**\r\n * An array of IMAGE tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const imgProperties = htmlElementProperties.concat([\r\n  'alt', // area, img, input\r\n  'crossOrigin', // img\r\n  'height', // canvas, embed, iframe, img, input, object, video\r\n  'src', // audio, embed, iframe, img, input, script, source, track, video\r\n  'srcSet', // img, source\r\n  'useMap', // img, object,\r\n  'width', // canvas, embed, iframe, img, input, object, video\r\n])\r\n\r\n/**\r\n * @deprecated Use imgProperties for img elements.\r\n */\r\nexport const imageProperties = imgProperties\r\n\r\n/**\r\n * An array of DIV tag properties and events.\r\n *\r\n * @public\r\n */\r\nexport const divProperties = htmlElementProperties\r\n\r\n/**\r\n * Gets native supported props for an html element provided the allowance set. Use one of the property\r\n * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given\r\n * props set. Note that all data- and aria- prefixed attributes will be allowed.\r\n * NOTE: getNativeProps should always be applied first when adding props to a react component. The\r\n * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.\r\n * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to\r\n * the component after an onClick function is added, then the getNativeProps onClick will override it.\r\n *\r\n * @public\r\n * @param props - The unfiltered input props\r\n * @param allowedPropsNames-  The array of allowed propnames.\r\n * @returns The filtered props\r\n */\r\nexport function getNativeProps<T> (props: {}, allowedPropNames: string[], excludedPropNames?: string[]): T {\r\n  // It'd be great to properly type this while allowing 'aria-` and 'data-' attributes like TypeScript does for JSX attributes,\r\n  // but that ability is hardcoded into the TS compiler with no analog in TypeScript typings.\r\n  // Then we'd be able to enforce props extends native props (including aria- and data- attributes), and then return native props.\r\n  // We should be able to do this once this PR is merged: https://github.com/microsoft/TypeScript/pull/26797\r\n  return filteredAssign(\r\n    (propName: string) => {\r\n      return (\r\n        (!excludedPropNames || excludedPropNames.indexOf(propName) < 0) &&\r\n        (propName.indexOf('data-') === 0 || propName.indexOf('aria-') === 0 || allowedPropNames.indexOf(propName) >= 0)\r\n      )\r\n    },\r\n    {},\r\n    props\r\n  ) as T\r\n}\r\n","/**\r\n * Regular expression matching characters to ignore when calculating the initials.\r\n * The first part matches characters within parenthesis, including the parenthesis.\r\n * The second part matches special ASCII characters except space, plus some unicode special characters.\r\n */\r\n// eslint-disable-next-line\r\nconst UNWANTED_CHARS_REGEX: RegExp = /\\([^)]*\\)|[\\0-\\u001F\\!-/:-@\\[-`\\{-\\u00BF\\u0250-\\u036F\\uD800-\\uFFFF]/g\r\n\r\n/**\r\n   * Regular expression matching phone numbers. Applied after chars matching UNWANTED_CHARS_REGEX have been removed\r\n   * and number has been trimmed for whitespaces\r\n   */\r\nconst PHONENUMBER_REGEX: RegExp = /^\\d+[\\d\\s]*(:?ext|x|)\\s*\\d+$/i\r\n\r\n/** Regular expression matching one or more spaces. */\r\nconst MULTIPLE_WHITESPACES_REGEX: RegExp = /\\s+/g\r\n\r\n/**\r\n   * Regular expression matching languages for which we currently don't support initials.\r\n   * Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.\r\n   * Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.\r\n   * Japanese: Hiragana, Katakana.\r\n   * CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs, CJK Unified Ideographs Extension B\r\n   */\r\n/* tslint:disable:max-line-length */\r\nconst UNSUPPORTED_TEXT_REGEX: RegExp = /[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uAC00-\\uD7AF\\uD7B0-\\uD7FF\\u3040-\\u309F\\u30A0-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uF900-\\uFAFF]|[\\uD840-\\uD869][\\uDC00-\\uDED6]/\r\n/* tslint:enable:max-line-length */\r\n\r\nfunction getInitialsLatin (displayName: string, isRtl: boolean): string {\r\n  let initials = ''\r\n\r\n  const splits: string[] = displayName.split(' ')\r\n\r\n  if (splits.length === 2) {\r\n    initials += splits[0].charAt(0).toUpperCase()\r\n    initials += splits[1].charAt(0).toUpperCase()\r\n  } else if (splits.length === 3) {\r\n    initials += splits[0].charAt(0).toUpperCase()\r\n    initials += splits[2].charAt(0).toUpperCase()\r\n  } else if (splits.length !== 0) {\r\n    initials += splits[0].charAt(0).toUpperCase()\r\n  }\r\n\r\n  if (isRtl && initials.length > 1) {\r\n    return initials.charAt(1) + initials.charAt(0)\r\n  }\r\n\r\n  return initials\r\n}\r\n\r\nfunction cleanupDisplayName (displayName: string): string {\r\n  displayName = displayName.replace(UNWANTED_CHARS_REGEX, '')\r\n  displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, ' ')\r\n  displayName = displayName.trim()\r\n\r\n  return displayName\r\n}\r\n\r\n/**\r\n   * Get (up to 2 characters) initials based on display name of the persona.\r\n   *\r\n   * @public\r\n   */\r\nexport function getInitials (displayName: string | undefined | null, isRtl: boolean, allowPhoneInitials?: boolean): string {\r\n  if (!displayName) {\r\n    return ''\r\n  }\r\n\r\n  displayName = cleanupDisplayName(displayName)\r\n\r\n  // For names containing CJK characters, and phone numbers, we don't display initials\r\n  if (UNSUPPORTED_TEXT_REGEX.test(displayName) || (!allowPhoneInitials && PHONENUMBER_REGEX.test(displayName))) {\r\n    return ''\r\n  }\r\n\r\n  return getInitialsLatin(displayName, isRtl)\r\n}\r\n","import { getDocument } from './dom/getDocument'\r\nimport { getItem, setItem } from './localStorage'\r\n\r\n// Default to undefined so that we initialize on first read.\r\nlet _language: string | null\r\n\r\n/**\r\n * Gets the rtl state of the page (returns true if in rtl.)\r\n *\r\n * @public\r\n */\r\nexport function getLanguage (): string | null {\r\n  if (_language === undefined) {\r\n    let doc = getDocument()\r\n    const savedLanguage = getItem('language')\r\n\r\n    if (savedLanguage !== null) {\r\n      _language = savedLanguage\r\n    }\r\n\r\n    if (_language === undefined && doc) {\r\n      _language = doc.documentElement.getAttribute('lang')\r\n    }\r\n\r\n    if (_language === undefined) {\r\n      _language = 'en'\r\n    }\r\n  }\r\n\r\n  return _language\r\n}\r\n\r\n/**\r\n * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)\r\n *\r\n * @public\r\n */\r\nexport function setLanguage (language: string, avoidPersisting: boolean = false): void {\r\n  let doc = getDocument()\r\n\r\n  if (doc) {\r\n    doc.documentElement.setAttribute('lang', language)\r\n  }\r\n\r\n  if (!avoidPersisting) {\r\n    setItem('language', language)\r\n  }\r\n\r\n  _language = language\r\n}\r\n","import { getDocument } from './dom/getDocument'\r\nimport { mergeStyles } from '@uifabric/merge-styles'\r\nimport { EventGroup } from './EventGroup'\r\nimport { getWindow } from './dom/getWindow'\r\n\r\nlet _scrollbarWidth: number\r\nlet _bodyScrollDisabledCount = 0\r\n\r\nconst DisabledScrollClassName = mergeStyles({\r\n  overflow: 'hidden !important' as 'hidden',\r\n})\r\n\r\n/**\r\n * Placing this attribute on scrollable divs optimizes detection to know\r\n * if the div is scrollable or not (given we can avoid expensive operations\r\n * like getComputedStyle.)\r\n *\r\n * @public\r\n */\r\nexport const DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable'\r\n\r\nconst _makeElementScrollAllower = () => {\r\n  let _previousClientY = 0\r\n  let _element: Element | null = null\r\n\r\n  // remember the clientY for future calls of _preventOverscrolling\r\n  const _saveClientY = (event: TouchEvent): void => {\r\n    if (event.targetTouches.length === 1) {\r\n      _previousClientY = event.targetTouches[0].clientY\r\n    }\r\n  }\r\n\r\n  // prevent the body from scrolling when the user attempts\r\n  // to scroll past the top or bottom of the element\r\n  const _preventOverscrolling = (event: TouchEvent): void => {\r\n    // only respond to a single-finger touch\r\n    if (event.targetTouches.length !== 1) {\r\n      return\r\n    }\r\n\r\n    // prevent the body touchmove handler from firing\r\n    // so that scrolling is allowed within the element\r\n    event.stopPropagation()\r\n\r\n    if (!_element) {\r\n      return\r\n    }\r\n\r\n    const clientY = event.targetTouches[0].clientY - _previousClientY\r\n\r\n    const scrollableParent = findScrollableParent(event.target as HTMLElement)\r\n    if (scrollableParent) {\r\n      _element = scrollableParent\r\n    }\r\n\r\n    // if the element is scrolled to the top,\r\n    // prevent the user from scrolling up\r\n    if (_element.scrollTop === 0 && clientY > 0) {\r\n      event.preventDefault()\r\n    }\r\n\r\n    // if the element is scrolled to the bottom,\r\n    // prevent the user from scrolling down\r\n    if (_element.scrollHeight - _element.scrollTop <= _element.clientHeight && clientY < 0) {\r\n      event.preventDefault()\r\n    }\r\n  }\r\n\r\n  return (element: HTMLElement | null, events: EventGroup): void => {\r\n    if (!element) {\r\n      return\r\n    }\r\n\r\n    events.on(element, 'touchstart', _saveClientY, { passive: false })\r\n    events.on(element, 'touchmove', _preventOverscrolling, { passive: false })\r\n\r\n    _element = element\r\n  }\r\n}\r\n\r\n/**\r\n * Allows the user to scroll within a element,\r\n * while preventing the user from scrolling the body\r\n */\r\nexport const allowScrollOnElement = _makeElementScrollAllower()\r\n\r\nconst _disableIosBodyScroll = (event: TouchEvent) => {\r\n  event.preventDefault()\r\n}\r\n\r\n/**\r\n * Disables the body scrolling.\r\n *\r\n * @public\r\n */\r\nexport function disableBodyScroll (): void {\r\n  let doc = getDocument()\r\n\r\n  if (doc && doc.body && !_bodyScrollDisabledCount) {\r\n    doc.body.classList.add(DisabledScrollClassName)\r\n    doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false })\r\n  }\r\n\r\n  _bodyScrollDisabledCount++\r\n}\r\n\r\n/**\r\n * Enables the body scrolling.\r\n *\r\n * @public\r\n */\r\nexport function enableBodyScroll (): void {\r\n  if (_bodyScrollDisabledCount > 0) {\r\n    let doc = getDocument()\r\n\r\n    if (doc && doc.body && _bodyScrollDisabledCount === 1) {\r\n      doc.body.classList.remove(DisabledScrollClassName)\r\n      doc.body.removeEventListener('touchmove', _disableIosBodyScroll)\r\n    }\r\n\r\n    _bodyScrollDisabledCount--\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the width of a scrollbar for the browser/os.\r\n *\r\n * @public\r\n */\r\nexport function getScrollbarWidth (): number {\r\n  if (_scrollbarWidth === undefined) {\r\n    let scrollDiv: HTMLElement = document.createElement('div')\r\n    scrollDiv.style.setProperty('width', '100px')\r\n    scrollDiv.style.setProperty('height', '100px')\r\n    scrollDiv.style.setProperty('overflow', 'scroll')\r\n    scrollDiv.style.setProperty('position', 'absolute')\r\n    scrollDiv.style.setProperty('top', '-9999px')\r\n    document.body.appendChild(scrollDiv)\r\n    // Get the scrollbar width\r\n    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\r\n\r\n    // Delete the DIV\r\n    document.body.removeChild(scrollDiv)\r\n  }\r\n\r\n  return _scrollbarWidth\r\n}\r\n\r\n/**\r\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\r\n * document.body.\r\n *\r\n * @public\r\n */\r\nexport function findScrollableParent (startingElement: HTMLElement | null): HTMLElement | null {\r\n  let el: HTMLElement | null = startingElement\r\n  const doc = getDocument(startingElement)!\r\n\r\n  // First do a quick scan for the scrollable attribute.\r\n  while (el && el !== doc.body) {\r\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\r\n      return el\r\n    }\r\n    el = el.parentElement\r\n  }\r\n\r\n  // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\r\n  el = startingElement\r\n\r\n  while (el && el !== doc.body) {\r\n    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\r\n      const computedStyles = getComputedStyle(el)\r\n      let overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : ''\r\n\r\n      if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\r\n        return el\r\n      }\r\n    }\r\n\r\n    el = el.parentElement\r\n  }\r\n\r\n  // Fall back to window scroll.\r\n  if (!el || el === doc.body) {\r\n    // tslint:disable-next-line:no-any\r\n    el = getWindow(startingElement) as any\r\n  }\r\n\r\n  return el\r\n}\r\n","/* tslint:disable:no-string-literal */\r\nimport { assign } from './object'\r\n\r\n/**\r\n * EventRecord interface.\r\n *\r\n * @internal\r\n */\r\n// tslint:disable:no-any\r\nexport interface IEventRecord {\r\n  target: any;\r\n  eventName: string;\r\n  parent: any;\r\n  callback: (args?: any) => void;\r\n  elementCallback?: (...args: any[]) => void;\r\n  objectCallback?: (args?: any) => void;\r\n  options?: boolean | AddEventListenerOptions;\r\n}\r\n// tslint:enable:no-any\r\n\r\n/**\r\n * EventRecordsByName interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IEventRecordsByName {\r\n  [eventName: string]: IEventRecordList;\r\n}\r\n\r\n/**\r\n * EventRecordList interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IEventRecordList {\r\n  [id: string]: IEventRecord[] | number;\r\n  count: number;\r\n}\r\n\r\n/**\r\n * DeclaredEventsByName interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IDeclaredEventsByName {\r\n  [eventName: string]: boolean;\r\n}\r\n\r\n/** An instance of EventGroup allows anything with a handle to it to trigger events on it.\r\n *  If the target is an HTMLElement, the event will be attached to the element and can be\r\n *  triggered as usual (like clicking for onclick).\r\n *  The event can be triggered by calling EventGroup.raise() here. If the target is an\r\n *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets\r\n *  handled here in EventGroup, and the handler is called in the context of the parent\r\n *  (which is passed in in the constructor).\r\n *\r\n * @public\r\n * {@docCategory EventGroup}\r\n */\r\nexport class EventGroup {\r\n  // tslint:disable-next-line:no-inferrable-types\r\n  private static _uniqueId: number = 0;\r\n  // tslint:disable-next-line:no-any\r\n  private _parent: any;\r\n  private _eventRecords: IEventRecord[];\r\n  private _id: number = EventGroup._uniqueId++;\r\n  private _isDisposed!: boolean;\r\n\r\n  /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.\r\n   *  Events raised here by default have bubbling set to false and cancelable set to true.\r\n   *  This applies also to built-in events being raised manually here on HTMLElements,\r\n   *  which may lead to unexpected behavior if it differs from the defaults.\r\n   *\r\n   */\r\n  public static raise (\r\n    // tslint:disable-next-line:no-any\r\n    target: any,\r\n    eventName: string,\r\n    // tslint:disable-next-line:no-any\r\n    eventArgs?: any,\r\n    bubbleEvent?: boolean\r\n  ): boolean | undefined {\r\n    let retVal\r\n\r\n    if (EventGroup._isElement(target)) {\r\n      if (typeof document !== 'undefined' && document.createEvent) {\r\n        let ev = document.createEvent('HTMLEvents')\r\n\r\n        ev.initEvent(eventName, bubbleEvent || false, true)\r\n\r\n        assign(ev, eventArgs)\r\n\r\n        retVal = target.dispatchEvent(ev)\r\n        // tslint:disable-next-line:no-any\r\n      } else if (typeof document !== 'undefined' && (document as any)['createEventObject']) {\r\n        // IE8\r\n        // tslint:disable-next-line:no-any\r\n        let evObj = (document as any)['createEventObject'](eventArgs)\r\n        // cannot set cancelBubble on evObj, fireEvent will overwrite it\r\n        target.fireEvent('on' + eventName, evObj)\r\n      }\r\n    } else {\r\n      while (target && retVal !== false) {\r\n        let events = <IEventRecordsByName>target.__events__\r\n        let eventRecords = events ? events[eventName] : null\r\n\r\n        if (eventRecords) {\r\n          for (let id in eventRecords) {\r\n            if (eventRecords.hasOwnProperty(id)) {\r\n              let eventRecordList = <IEventRecord[]>eventRecords[id]\r\n\r\n              for (let listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {\r\n                let record = eventRecordList[listIndex]\r\n\r\n                if (record.objectCallback) {\r\n                  retVal = record.objectCallback.call(record.parent, eventArgs)\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // If the target has a parent, bubble the event up.\r\n        target = bubbleEvent ? target.parent : null\r\n      }\r\n    }\r\n\r\n    return retVal\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public static isObserved (target: any, eventName: string): boolean {\r\n    let events = target && <IEventRecordsByName>target.__events__\r\n\r\n    return !!events && !!events[eventName]\r\n  }\r\n\r\n  /** Check to see if the target has declared support of the given event. */\r\n  // tslint:disable-next-line:no-any\r\n  public static isDeclared (target: any, eventName: string): boolean {\r\n    let declaredEvents = target && <IDeclaredEventsByName>target.__declaredEvents\r\n\r\n    return !!declaredEvents && !!declaredEvents[eventName]\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public static stopPropagation (event: any): void {\r\n    if (event.stopPropagation) {\r\n      event.stopPropagation()\r\n    } else {\r\n      // IE8\r\n      event.cancelBubble = true\r\n    }\r\n  }\r\n\r\n  private static _isElement (target: HTMLElement): boolean {\r\n    return !!target && (!!target.addEventListener || (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement))\r\n  }\r\n\r\n  /** parent: the context in which events attached to non-HTMLElements are called */\r\n  // tslint:disable-next-line:no-any\r\n  public constructor (parent: any) {\r\n    this._parent = parent\r\n    this._eventRecords = []\r\n  }\r\n\r\n  public dispose (): void {\r\n    if (!this._isDisposed) {\r\n      this._isDisposed = true\r\n\r\n      this.off()\r\n      this._parent = null\r\n    }\r\n  }\r\n\r\n  /** On the target, attach a set of events, where the events object is a name to function mapping. */\r\n  // tslint:disable-next-line:no-any\r\n  public onAll (target: any, events: { [key: string]: (args?: any) => void }, useCapture?: boolean): void {\r\n    for (let eventName in events) {\r\n      if (events.hasOwnProperty(eventName)) {\r\n        this.on(target, eventName, events[eventName], useCapture)\r\n      }\r\n    }\r\n  }\r\n\r\n  /** On the target, attach an event whose handler will be called in the context of the parent\r\n   * of this instance of EventGroup.\r\n   */\r\n  // tslint:disable-next-line:no-any\r\n  public on (target: any, eventName: string, callback: (args?: any) => void, options?: boolean | AddEventListenerOptions): void {\r\n    if (eventName.indexOf(',') > -1) {\r\n      let events = eventName.split(/[ ,]+/)\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        this.on(target, events[i], callback, options)\r\n      }\r\n    } else {\r\n      let parent = this._parent\r\n      let eventRecord: IEventRecord = {\r\n        target: target,\r\n        eventName: eventName,\r\n        parent: parent,\r\n        callback: callback,\r\n        options,\r\n      }\r\n\r\n      // Initialize and wire up the record on the target, so that it can call the callback if the event fires.\r\n      let events = <IEventRecordsByName>(target.__events__ = target.__events__ || {})\r\n      events[eventName] =\r\n        events[eventName] ||\r\n        <IEventRecordList>{\r\n          count: 0,\r\n        }\r\n      events[eventName][this._id] = events[eventName][this._id] || [];\r\n      (<IEventRecord[]>events[eventName][this._id]).push(eventRecord)\r\n      events[eventName].count++\r\n\r\n      if (EventGroup._isElement(target)) {\r\n        // tslint:disable-next-line:no-any\r\n        let processElementEvent = (...args: any[]) => {\r\n          if (this._isDisposed) {\r\n            return\r\n          }\r\n\r\n          let result\r\n          try {\r\n            // @ts-ignore\r\n            result = callback.apply(parent, args)\r\n            if (result === false && args[0]) {\r\n              let e = args[0]\r\n\r\n              if (e.preventDefault) {\r\n                e.preventDefault()\r\n              }\r\n\r\n              if (e.stopPropagation) {\r\n                e.stopPropagation()\r\n              }\r\n\r\n              e.cancelBubble = true\r\n            }\r\n          } catch (e) {\r\n            /* ErrorHelper.log(e); */\r\n          }\r\n\r\n          return result\r\n        }\r\n\r\n        eventRecord.elementCallback = processElementEvent\r\n\r\n        if (target.addEventListener) {\r\n          /* tslint:disable:ban-native-functions */\r\n          (<EventTarget>target).addEventListener(eventName, processElementEvent, options)\r\n          /* tslint:enable:ban-native-functions */\r\n        } else if (target.attachEvent) {\r\n          // IE8\r\n          target.attachEvent('on' + eventName, processElementEvent)\r\n        }\r\n      } else {\r\n        // tslint:disable-next-line:no-any\r\n        let processObjectEvent = (...args: any[]) => {\r\n          if (this._isDisposed) {\r\n            return\r\n          }\r\n\r\n          // @ts-ignore\r\n          return callback.apply(parent, args)\r\n        }\r\n\r\n        eventRecord.objectCallback = processObjectEvent\r\n      }\r\n\r\n      // Remember the record locally, so that it can be removed.\r\n      this._eventRecords.push(eventRecord)\r\n    }\r\n  }\r\n\r\n  // tslint:disable-next-line:no-any\r\n  public off (target?: any, eventName?: string, callback?: (args?: any) => void, options?: boolean | AddEventListenerOptions): void {\r\n    for (let i = 0; i < this._eventRecords.length; i++) {\r\n      let eventRecord = this._eventRecords[i]\r\n      if (\r\n        (!target || target === eventRecord.target) &&\r\n        (!eventName || eventName === eventRecord.eventName) &&\r\n        (!callback || callback === eventRecord.callback) &&\r\n        (typeof options !== 'boolean' || options === eventRecord.options)\r\n      ) {\r\n        let events = <IEventRecordsByName>eventRecord.target.__events__\r\n        let targetArrayLookup = events[eventRecord.eventName]\r\n        let targetArray = targetArrayLookup ? <IEventRecord[]>targetArrayLookup[this._id] : null\r\n\r\n        // We may have already target's entries, so check for null.\r\n        if (targetArray) {\r\n          if (targetArray.length === 1 || !callback) {\r\n            targetArrayLookup.count -= targetArray.length\r\n            delete events[eventRecord.eventName][this._id]\r\n          } else {\r\n            targetArrayLookup.count--\r\n            targetArray.splice(targetArray.indexOf(eventRecord), 1)\r\n          }\r\n\r\n          if (!targetArrayLookup.count) {\r\n            delete events[eventRecord.eventName]\r\n          }\r\n        }\r\n\r\n        if (eventRecord.elementCallback) {\r\n          if (eventRecord.target.removeEventListener) {\r\n            eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options)\r\n          } else if (eventRecord.target.detachEvent) {\r\n            // IE8\r\n            eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback)\r\n          }\r\n        }\r\n\r\n        this._eventRecords.splice(i--, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Trigger the given event in the context of this instance of EventGroup. */\r\n  // tslint:disable-next-line:no-any\r\n  public raise (eventName: string, eventArgs?: any, bubbleEvent?: boolean): boolean | undefined {\r\n    return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent)\r\n  }\r\n\r\n  /** Declare an event as being supported by this instance of EventGroup. */\r\n  public declare (event: string | string[]): void {\r\n    let declaredEvents = (this._parent.__declaredEvents = this._parent.__declaredEvents || {})\r\n\r\n    if (typeof event === 'string') {\r\n      declaredEvents[event] = true\r\n    } else {\r\n      for (let i = 0; i < event.length; i++) {\r\n        declaredEvents[event[i]] = true\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { extractStyleParts } from './extractStyleParts';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { styleToClassName } from './styleToClassName';\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n *\n * @public\n */\nexport function mergeStyles() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return mergeCss(args, getStyleOptions());\n}\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n * Accepts a set of options that will be used when calculating styles.\n *\n * @public\n */\nexport function mergeCss(args, options) {\n    var styleArgs = args instanceof Array ? args : [args];\n    var _a = extractStyleParts(styleArgs), classes = _a.classes, objects = _a.objects;\n    if (objects.length) {\n        classes.push(styleToClassName(options || {}, objects));\n    }\n    return classes.join(' ');\n}\n//# sourceMappingURL=mergeStyles.js.map","// import { DirectionalHint } from '../../common/DirectionalHint'\r\nimport { IRectangle } from './IRectangle'\r\n\r\nexport enum RectangleEdge {\r\n  top = 1,\r\n  bottom = -1,\r\n  left = 2,\r\n  right = -2\r\n}\r\n\r\nexport enum Position {\r\n  top = 0,\r\n  bottom = 1,\r\n  start = 2,\r\n  end = 3\r\n}\r\nexport interface IPositionProps {\r\n  target?: Element | MouseEvent | IPoint;\r\n  /** how the element should be positioned */\r\n  directionalHint?: any;\r\n  /**\r\n   * How the element should be positioned in RTL layouts.\r\n   * If not specified, a mirror of `directionalHint` will be used instead\r\n   */\r\n  directionalHintForRTL?: any;\r\n  /** The gap between the callout and the target */\r\n  gapSpace?: number;\r\n  /**\r\n   * The bounding rectangle for which  the contextual menu can appear in.\r\n   */\r\n  bounds?: IRectangle;\r\n  /**\r\n   * If true the position returned will have the menu element cover the target.\r\n   * If false then it will position next to the target;\r\n   */\r\n  coverTarget?: boolean;\r\n  /**\r\n   * If true the position will not change edges in an attempt to fit the rectangle within bounds.\r\n   * It will still attempt to align it to whatever bounds are given.\r\n   * @defaultvalue false\r\n   */\r\n  directionalHintFixed?: boolean;\r\n\r\n  /**\r\n   * If true the positioning logic will prefer flipping edges over nudging the rectangle to fit within bounds,\r\n   * thus making sure the element align perfectly with target.\r\n   */\r\n  alignTargetEdge?: boolean;\r\n}\r\n\r\nexport interface ICalloutPositionProps extends IPositionProps {\r\n  /**\r\n   * The width of the beak.\r\n   */\r\n  beakWidth?: number;\r\n\r\n  /**\r\n   * Whether or not the beak is visible\r\n   */\r\n  isBeakVisible?: boolean;\r\n}\r\n\r\nexport interface IPositionedData {\r\n  /**\r\n   * The new position of the element.\r\n   */\r\n  elementPosition: IPosition;\r\n  /**\r\n   * The finalized target edge that element is aligning to. For instance RectangleEdge.bottom would mean\r\n   * that the bottom edge of the target is being aligned to by the RectangleEdge.top of the element\r\n   * that is being positioned.\r\n   */\r\n  targetEdge: RectangleEdge;\r\n  /**\r\n   * The finalized alignment edge that the element is aligning too. For instance, RectangleEdge.left means\r\n   * that the left edge of the target should be in line with the left edge of the element being positioned.\r\n   */\r\n  alignmentEdge?: RectangleEdge;\r\n}\r\n\r\nexport interface ICalloutPositionedInfo extends IPositionedData {\r\n  beakPosition: ICalloutBeakPositionedInfo;\r\n}\r\n\r\nexport interface ICalloutBeakPositionedInfo extends IPositionedData {\r\n  closestEdge: RectangleEdge;\r\n}\r\n\r\n/**\r\n * Gives the position of some element on the page. Only a pair of vertical and horizontal edges need to be\r\n * given. So top/left or bottom/left is sufficient.\r\n * The number given is the distance in pixels from whatever host was given..\r\n * So bottom: 100 would be 100px up from the bottom of the host while top: 100px from the top.\r\n */\r\nexport interface IPosition {\r\n  top?: number;\r\n  left?: number;\r\n  bottom?: number;\r\n  right?: number;\r\n  [key: string]: number | undefined;\r\n}\r\n\r\nexport interface IPoint {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface IPositionDirectionalHintData {\r\n  targetEdge: RectangleEdge;\r\n  alignmentEdge?: RectangleEdge;\r\n  isAuto?: boolean;\r\n  alignTargetEdge?: boolean;\r\n}\r\n\r\nexport interface IRelativePositions {\r\n  calloutPosition: IPosition;\r\n  beakPosition: { position: IPosition | undefined; display: 'block' };\r\n  directionalClassName: string;\r\n  submenuDirection: any;\r\n}\r\n","/**\r\n * Rectangle helper class.\r\n *\r\n * @public\r\n * {@docCategory Rectangle}\r\n */\r\nexport class Rectangle {\r\n  public top: number;\r\n  public bottom: number;\r\n  public left: number;\r\n  public right: number;\r\n\r\n  constructor (left: number = 0, right: number = 0, top: number = 0, bottom: number = 0) {\r\n    this.top = top\r\n    this.bottom = bottom\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n\r\n  /**\r\n   * Calculated automatically by subtracting the right from left\r\n   */\r\n  get width (): number {\r\n    return this.right - this.left\r\n  }\r\n\r\n  /**\r\n   * Calculated automatically by subtracting the bottom from top.\r\n   */\r\n  get height (): number {\r\n    return this.bottom - this.top\r\n  }\r\n\r\n  /**\r\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\r\n   */\r\n  public equals (rect: Rectangle): boolean {\r\n    // I'm fixing it to 4 decimal places because it allows enough precision and will handle cases when something should be rounded,\r\n    // like .999999 should round to 1.\r\n    return (\r\n      parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&\r\n      parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&\r\n      parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&\r\n      parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4))\r\n    )\r\n  }\r\n}\r\n","let _warningCallback: ((message: string) => void) | undefined\r\n\r\nexport type ISettingsMap<T> = { [P in keyof T]?: string };\r\n\r\n/**\r\n * Sends a warning to console, if the api is present.\r\n *\r\n * @public\r\n * @param message - Warning message.\r\n */\r\nexport function warn (message: string): void {\r\n  if (_warningCallback && process.env.NODE_ENV !== 'production') {\r\n    _warningCallback(message)\r\n  } else if (console && console.warn) {\r\n    console.warn(message)\r\n  }\r\n}\r\n\r\n/**\r\n * Configures the warning callback. Passing in undefined will reset it to use the default\r\n * console.warn function.\r\n *\r\n * @public\r\n * @param warningCallback - Callback to override the generated warnings.\r\n */\r\nexport function setWarningCallback (warningCallback?: (message: string) => void): void {\r\n  _warningCallback = warningCallback\r\n}\r\n","/**\r\n * Dictionary of booleans.\r\n *\r\n * @internal\r\n */\r\nexport interface IDictionary {\r\n  [className: string]: boolean;\r\n}\r\n\r\n/**\r\n * Serializable object.\r\n *\r\n * @internal\r\n */\r\nexport interface ISerializableObject {\r\n  toString?: () => string;\r\n}\r\n\r\n/**\r\n * css input type.\r\n *\r\n * @internal\r\n */\r\nexport type ICssInput = string | ISerializableObject | IDictionary | null | undefined | boolean;\r\n\r\n/**\r\n * Concatination helper, which can merge class names together. Skips over falsey values.\r\n *\r\n * @public\r\n */\r\nexport function css (...args: ICssInput[]): string {\r\n  let classes: string[] = []\r\n\r\n  for (let arg of args) {\r\n    if (arg) {\r\n      if (typeof arg === 'string') {\r\n        classes.push(arg)\r\n      } else if (arg.hasOwnProperty('toString') && typeof arg.toString === 'function') {\r\n        classes.push(arg.toString())\r\n      } else {\r\n        for (let key in arg as any) {\r\n          if ((arg as any)[key]) {\r\n            classes.push(key)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return classes.join(' ')\r\n}\r\n","import { getParent } from './getParent'\r\n/**\r\n * Determines whether or not a parent element contains a given child element.\r\n * If `allowVirtualParents` is true, this method may return `true` if the child\r\n * has the parent in its virtual element hierarchy.\r\n *\r\n * @public\r\n */\r\nexport function elementContains (parent: HTMLElement | null, child: HTMLElement | null, allowVirtualParents: boolean = true): boolean {\r\n  let isContained = false\r\n  if (parent && child) {\r\n    if (allowVirtualParents) {\r\n      isContained = false\r\n      while (child) {\r\n        let nextParent: HTMLElement | null = getParent(child)\r\n        if (nextParent === parent) {\r\n          isContained = true\r\n          break\r\n        }\r\n        child = nextParent\r\n      }\r\n    } else if (parent.contains) {\r\n      isContained = parent.contains(child)\r\n    }\r\n  }\r\n  return isContained\r\n}\r\n","import { getWindow } from './dom/getWindow'\r\n\r\n/**\r\n * Fetches an item from local storage without throwing an exception\r\n * @param key The key of the item to fetch from local storage\r\n */\r\nexport function getItem (key: string): string | null {\r\n  let result: string | null = null\r\n  try {\r\n    const win = getWindow()\r\n    result = win ? win.localStorage.getItem(key) : null\r\n  } catch (e) {\r\n    /* Eat the exception */\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Inserts an item into local storage without throwing an exception\r\n * @param key The key of the item to add to local storage\r\n * @param data The data to put into local storage\r\n */\r\nexport function setItem (key: string, data: string): void {\r\n  try {\r\n    const win = getWindow()\r\n\r\n    win && win.localStorage.setItem(key, data)\r\n  } catch (e) {\r\n    /* Eat the exception */\r\n  }\r\n}\r\n","export const isIE11 = (): boolean => {\r\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\r\n    return false\r\n  }\r\n\r\n  return window.navigator.userAgent.indexOf('rv:11.0') > -1\r\n}\r\n","export function on (element: Element | Window, eventName: string, callback: (ev: Event) => void, options?: boolean): () => void {\r\n  element.addEventListener(eventName, callback, options)\r\n\r\n  return () => element.removeEventListener(eventName, callback, options)\r\n}\r\n","import { warn } from './warn'\r\n/**\r\n * Warns when props are required if a condition is met.\r\n *\r\n * @public\r\n * @param componentName - The name of the component being used.\r\n * @param props - The props passed into the component.\r\n * @param requiredProps - The name of the props that are required when the condition is met.\r\n * @param conditionalPropName - The name of the prop that the condition is based on.\r\n * @param condition - Whether the condition is met.\r\n */\r\nexport function warnConditionallyRequiredProps<P> (\r\n  componentName: string,\r\n  props: P,\r\n  requiredProps: string[],\r\n  conditionalPropName: string,\r\n  condition: boolean\r\n): void {\r\n  if (condition === true && process.env.NODE_ENV !== 'production') {\r\n    for (const requiredPropName of requiredProps) {\r\n      if (!(requiredPropName in props)) {\r\n        warn(`${componentName} property '${requiredPropName}' is required when '${conditionalPropName}' is used.'`)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { warn } from './warn'\r\nimport { isControlled as checkIsControlled } from '../controlled'\r\n\r\ntype WarningMap = { [id: string]: boolean };\r\n\r\nlet warningsMap: {\r\n  valueOnChange: WarningMap;\r\n  valueDefaultValue: WarningMap;\r\n  controlledToUncontrolled: WarningMap;\r\n  uncontrolledToControlled: WarningMap;\r\n}\r\nif (process.env.NODE_ENV !== 'production') {\r\n  warningsMap = {\r\n    valueOnChange: {},\r\n    valueDefaultValue: {},\r\n    controlledToUncontrolled: {},\r\n    uncontrolledToControlled: {},\r\n  }\r\n}\r\n\r\n/** Reset controlled usage warnings for testing purposes. */\r\nexport function resetControlledWarnings (): void {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    warningsMap.valueOnChange = {}\r\n    warningsMap.valueDefaultValue = {}\r\n    warningsMap.controlledToUncontrolled = {}\r\n    warningsMap.uncontrolledToControlled = {}\r\n  }\r\n}\r\n\r\nexport interface IWarnControlledUsageParams<P> {\r\n  /** ID of the component instance. Used to prevent showing warnings repeatedly. */\r\n  componentId: string;\r\n  /** Name of the component class. */\r\n  componentName: string;\r\n  /** Current props to evaluate. */\r\n  props: P;\r\n  /** Previous props to evaluate (undefined if called in the constructor). */\r\n  oldProps?: P;\r\n  /** Name of the prop for the controlled value. */\r\n  valueProp: keyof P;\r\n  /** Name of the prop for the uncontrolled initial value. */\r\n  defaultValueProp: keyof P;\r\n  /** Name of the change handler prop. */\r\n  onChangeProp: keyof P;\r\n  /** Name of the read-only prop. */\r\n  readOnlyProp?: keyof P;\r\n}\r\n\r\n/**\r\n * Check for and warn on the following error conditions with a form component:\r\n * - A value prop is provided (indicated it's being used as controlled) without a change handler,\r\n *    and the component is not read-only\r\n * - Both the value and defaultValue props are provided\r\n * - The component is attempting to switch between controlled and uncontrolled\r\n * - The value or default value are null (unless allowNullValue is set)\r\n *\r\n * The messages mimic the warnings React gives for these error conditions on input elements.\r\n * The warning will only be displayed once per component ID.\r\n */\r\nexport function warnControlledUsage<P> (params: IWarnControlledUsageParams<P>): void {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    const { componentId, componentName, defaultValueProp, props, oldProps, onChangeProp, readOnlyProp, valueProp } = params\r\n\r\n    // This warning logic closely follows what React does for native <input> elements.\r\n\r\n    const oldIsControlled = oldProps ? checkIsControlled(oldProps, valueProp) : undefined\r\n    const newIsControlled = checkIsControlled(props, valueProp)\r\n\r\n    if (newIsControlled) {\r\n      // onChange (or readOnly) must be provided if value is provided\r\n      const hasOnChange = !!props[onChangeProp]\r\n      const isReadOnly = !!(readOnlyProp && props[readOnlyProp])\r\n      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {\r\n        warningsMap.valueOnChange[componentId] = true\r\n        warn(\r\n          `Warning: You provided a '${valueProp}' prop to a ${componentName} without an '${onChangeProp}' handler. ` +\r\n            `This will render a read-only field. If the field should be mutable use '${defaultValueProp}'. ` +\r\n            `Otherwise, set '${onChangeProp}'${readOnlyProp ? ` or '${readOnlyProp}'` : ''}.`\r\n        )\r\n      }\r\n\r\n      // value and defaultValue are mutually exclusive\r\n      const defaultValue = props[defaultValueProp]\r\n      if (defaultValue !== undefined && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {\r\n        warningsMap.valueDefaultValue[componentId] = true\r\n        warn(\r\n          `Warning: You provided both '${valueProp}' and '${defaultValueProp}' to a ${componentName}. ` +\r\n            `Form fields must be either controlled or uncontrolled (specify either the '${valueProp}' prop, ` +\r\n            `or the '${defaultValueProp}' prop, but not both). Decide between using a controlled or uncontrolled ` +\r\n            `${componentName} and remove one of these props. More info: https://fb.me/react-controlled-components`\r\n        )\r\n      }\r\n    }\r\n\r\n    // Warn if switching between uncontrolled and controlled. (One difference between this implementation\r\n    // and React's <input> is that if oldIsControlled is indeterminate and newIsControlled true, we don't warn.)\r\n    if (oldProps && newIsControlled !== oldIsControlled) {\r\n      const oldType = oldIsControlled ? 'a controlled' : 'an uncontrolled'\r\n      const newType = oldIsControlled ? 'uncontrolled' : 'controlled'\r\n      const warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled\r\n      if (!warnMap[componentId]) {\r\n        warnMap[componentId] = true\r\n        warn(\r\n          `Warning: A component is changing ${oldType} ${componentName} to be ${newType}. ` +\r\n            `${componentName}s should not switch from controlled to uncontrolled (or vice versa). ` +\r\n            `Decide between using controlled or uncontrolled for the lifetime of the component. ` +\r\n            `More info: https://fb.me/react-controlled-components`\r\n        )\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ISettingsMap, warn } from './warn'\r\n/**\r\n * Warns when a deprecated props are being used.\r\n *\r\n * @public\r\n * @param componentName - The name of the component being used.\r\n * @param props - The props passed into the component.\r\n * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\r\n * either null or a replacement prop name.\r\n */\r\nexport function warnDeprecations<P> (componentName: string, props: P, deprecationMap: ISettingsMap<P>): void {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    for (const propName in deprecationMap) {\r\n      if (props && propName in props) {\r\n        let deprecationMessage = `${componentName} property '${propName}' was used but has been deprecated.`\r\n        const replacementPropName = deprecationMap[propName]\r\n        if (replacementPropName) {\r\n          deprecationMessage += ` Use '${replacementPropName}' instead.`\r\n        }\r\n        warn(deprecationMessage)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ISettingsMap, warn } from './warn'\r\n/**\r\n * Warns when two props which are mutually exclusive are both being used.\r\n *\r\n * @public\r\n * @param componentName - The name of the component being used.\r\n * @param props - The props passed into the component.\r\n * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.\r\n */\r\nexport function warnMutuallyExclusive<P> (componentName: string, props: P, exclusiveMap: ISettingsMap<P>): void {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    for (const propName in exclusiveMap) {\r\n      if (props && props[propName] !== undefined) {\r\n        let propInExclusiveMapValue = exclusiveMap[propName]\r\n        if (propInExclusiveMapValue && props[propInExclusiveMapValue as keyof P] !== undefined) {\r\n          warn(`${componentName} property '${propName}' is mutually exclusive with '${exclusiveMap[propName]}'. Use one or the other.`)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["getDocument","rootElement","_isSSR","document","el","ownerDocument","_window","window","e","getWindow","defaultView","Async","parent","onError","_isDisposed","_parent","_onErrorHandler","_noop","id","this","_timeoutIds","hasOwnProperty","clearTimeout","parseInt","_immediateIds","clearImmediate","_intervalIds","clearInterval","_animationFrameIds","cancelAnimationFrame","callback","duration","timeoutId","setTimeout","_this","apply","targetElement","immediateId","win","_this2","_logError","intervalId","setInterval","_this3","func","wait","options","lastResult","lastArgs","waitMS","leading","trailing","lastExecuteTime","args","userCall","now","Date","getTime","delta","waitLength","_this4","noOpFunction","cancel","flush","pending","maxWait","lastCallTime","isNaN","markExecuted","time","_this5","invokeFunction","resultFunction","executeImmediately","maxWaitDelta","maxWaitExpired","Math","min","animationFrameId","animationFrameCallback","_this6","requestAnimationFrame","getParent","child","allowVirtualParents","element","_virtual","getVirtualParent","parentNode","elementContainsAttribute","attribute","elementMatch","findElementRecursive","matchFunction","body","testElement","hasAttribute","getAttribute","targetToFocusOnNextRepaint","IS_FOCUSABLE_ATTRIBUTE","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","getPreviousElement","currentElement","checkNode","suppressParentTraversal","traverseChildren","includeElementsInFocusZones","allowFocusRoot","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","childMatch","lastElementChild","isElementTabbable","childMatchSiblingMatch","previousElementSibling","childMatchParent","parentElement","childMatchParentMatch","siblingMatch","getNextElement","suppressChildTraversal","firstElementChild","nextElementSibling","visibilityAttribute","offsetHeight","offsetParent","isVisible","checkTabIndex","disabled","tabIndex","tabIndexAttributeValue","isFocusableAttribute","isTabIndexSet","result","tagName","focusAsync","focus","undefined","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","call","__spreadArrays","il","r","Array","k","a","j","jl","_stylesheet","InjectionMode","none","insertNode","appendChild","REUSE_STYLE_NODE","navigator","test","userAgent","_global","_a","Stylesheet","config","_rules","_preservedRules","_rulesToInsert","_counter","_keyToClassName","_onResetCallbacks","_classNameToArgs","_config","injectionMode","defaultPrefix","namespace","cspSettings","getInstance","_lastStyleElement","fabricConfig","mergeStyles","setConfig","onReset","push","getClassName","displayName","cacheClassName","className","key","rules","classNameFromKey","argsFromClassName","entry","insertedRulesFromClassName","insertRule","rule","preserve","_getStyleElement","sheet","cssRules","createTextNode","onInsertRule","getRules","includePreservedRules","join","reset","forEach","resetKeys","_styleElement","_createStyleElement","head","styleElement","createElement","setAttribute","nonce","insertBefore","placeholderStyleTag","_findPlaceholderStyleTag","childNodes","querySelector","extractStyleParts","_i","classes","objects","stylesheet","_processArgs","argsList","argsList_1","arg","indexOf","split","translatedArgs","isArray","_typeof","setRTL","isRTL","_rtl","getRTL","documentElement","_vendorSettings","autoPrefixNames","prefixRules","rulePairs","index","vendorSettings","doc","nav","toLowerCase","isWebkit","style","isMoz","isOpera","isMs","getVendorSettings","name","value","NON_PIXEL_NUMBER_PROPS","provideUnits","unit","LEFT","RIGHT","NO_FLIP","NAME_REPLACEMENTS","VALUE_REPLACEMENTS","rtlifyRules","rtl","name_1","replace","String","parts","flipQuad","partIndex","numberVal","negateNum","DISPLAY_NAME","globalSelectorRegExp","expandCommaSeparatedGlobals","selectorWithGlobals","replacementInfo","findGlobal","match","exec","map","v","trim","reverse","reduce","selector","matchIndex","matchEndIndex","replacement","slice","expandSelector","newSelector","currentSelector","expandQuads","currentRules","serializeRuleEntries","ruleEntries","allEntries","splice","styleToRegistration","extractRules","__order","args_1","expandedRules","prop","selectors","selectorValue_1","separatedSelector","serialized","hasProps","rulesForSelector","propName","getKeyForRules","registration","rootStyle","getDisplayName","rulesToInsert","_b","applyRegistration","processedRule","mergeCssSets","styleSets","classNameSet","subComponentStyles","concatenatedStyleSet","concatStyleSets","mergedSet","workingSubcomponentStyles","styleSets_1","currentSet","currentComponentStyles","subCompProp","mergedValue","currentValue","keys","mergedSubStyles","workingSet_1","styleProps","styleFunctionOrObject","registrations","styleSetArea","concat","registrations_1","packagesCache","_win","setVersion","packageName","packageVersion","packages","__packages__","KeyCodes","backspace","tab","enter","shift","ctrl","alt","pauseBreak","capslock","escape","space","pageUp","pageDown","end","home","left","up","right","down","insert","del","zero","one","two","three","four","five","six","seven","eight","nine","b","c","d","f","g","h","l","m","o","q","u","w","x","y","z","leftWindow","rightWindow","select","zero_numpad","one_numpad","two_numpad","three_numpad","four_numpad","five_numpad","six_numpad","seven_numpad","eight_numpad","nine_numpad","multiply","add","subtract","decimalPoint","divide","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","numlock","scrollLock","semicolon","equalSign","comma","dash","period","forwardSlash","graveAccent","openBracket","backSlash","closeBracket","singleQuote","_isRTL","RTL_LOCAL_STORAGE_KEY","theme","savedRTL","sessionStorage","getItem","mergeStylesSetRTL","persistSetting","data","setItem","MAX_CACHE_COUNT","_memoizedClassNames","RetVal","_traverseEdge","current","_normalizeValue","has","set","Map","get","_traverseMap","inputs","__cachedInputs__","GLOBAL_SETTINGS_PROP_NAME","CALLBACK_STATE_PROP_NAME","GlobalSettings","defaultValue","globalSettings","_getGlobalSettings","callbacks","oldValue","changeDescription","cb","__id__","_getCallbacks","globalObj","NO_CUSTOMIZATIONS","settings","scopedSettings","inCustomizerContext","_allSettings","getValue","_events","Customizations","_raiseChange","scopeName","properties","localSettings","localScopedSettings","globalScopedSettings","property","onChange","filter","_isSettingsFunction","findIndex","array","DirectionalKeyCodes","isDirectionalKeyCode","which","IsFocusVisibleClassName","_onMouseDown","ev","target","classList","contains","remove","_onKeyDown","resetMemoizations","_resetCounter","_emptyObject","empty","_dictionary","_weakMap","WeakMap","memoizeFunction","rootNode","maxCacheSize","cacheSize","localResetCounter","currentNode","_createNode","_normalizeArg","val","_merge","source","circularReferences","isCircularReference","pop","CURRENT_ID_PROPERTY","DEFAULT_ID_STRING","resetIds","counter","checkProperties","filteredAssign","isAllowed","sourceObject","baseElementEvents","baseElementProperties","htmlElementProperties","labelProperties","audioProperties","videoProperties","olProperties","liProperties","anchorProperties","buttonProperties","inputProperties","textAreaProperties","selectProperties","optionProperties","tableProperties","trProperties","thProperties","tdProperties","colGroupProperties","colProperties","formProperties","iframeProperties","imgProperties","imageProperties","divProperties","_language","UNWANTED_CHARS_REGEX","PHONENUMBER_REGEX","MULTIPLE_WHITESPACES_REGEX","UNSUPPORTED_TEXT_REGEX","_scrollbarWidth","EventGroup","_uniqueId","_eventRecords","off","events","useCapture","eventName","on","eventRecord","__events__","count","_id","_isElement","processElementEvent","preventDefault","stopPropagation","cancelBubble","elementCallback","addEventListener","attachEvent","objectCallback","targetArrayLookup","targetArray","removeEventListener","detachEvent","eventArgs","bubbleEvent","raise","event","declaredEvents","__declaredEvents","retVal","createEvent","initEvent","dispatchEvent","evObj","fireEvent","eventRecords","eventRecordList","listIndex","record","HTMLElement","_previousClientY","_element","_saveClientY","_preventOverscrolling","_bodyScrollDisabledCount","DisabledScrollClassName","styleToClassName","mergeCss","overflow","DATA_IS_SCROLLABLE_ATTRIBUTE","allowScrollOnElement","targetTouches","clientY","scrollableParent","findScrollableParent","scrollTop","scrollHeight","clientHeight","passive","_disableIosBodyScroll","startingElement","computedStyles","getComputedStyle","overflowY","getPropertyValue","RectangleEdge","Position","Rectangle","top","bottom","rect","parseFloat","toFixed","warn","message","console","itemToAdd","copy","array1","array2","resultCount","currentMemoizedClassNames","disableCaching","clear","size","toString","capture","currentActiveElement","activeElement","isContained","nextParent","elementContains","item","fromElement","toElement","path","unshift","children","nextChild","prefix","isRtl","allowPhoneInitials","cleanupDisplayName","initials","splits","charAt","toUpperCase","getInitialsLatin","savedLanguage","localStorage","props","allowedPropNames","excludedPropNames","scrollDiv","setProperty","offsetWidth","clientWidth","removeChild","__hasInitializeFocusRects__","theEnum","Number","descriptor","fn","bind","configurable","oldSettings","newSettings","scopedSettingsFromProps","oldScopedSettings","newScopedSettings","_scopedSettingsMergeWith","_settingsMergeWith","_","newElement","language","avoidPersisting","weakMap","isEnabled","warningCallback","noWrapDataAttribute","items","columnCount","rows","obj","arr","componentName","requiredProps","conditionalPropName","condition","params","deprecationMap","exclusiveMap"],"mappings":"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AAYpK,KACfA,EAAE3I,eAAe+S,MACdsE,EAAErX,eAAe+S,IAAasE,EAAEtE,KAAcpK,EAAEoK,WAC5C,SAKN,WAuBOnL,GAAQiX,8BAAgB7c,mCAAAA,2BAE/B4e,GAAe9f,MAAMhB,KAAM,CAAC,KAAM+e,GAAQhK,OAAO7S,aAgB1C4e,GAAgBC,EAA0ChC,GACxEA,EAASA,GAAU,8BADqE7c,mCAAAA,kCAG/DA,iBAAM,KAAtB8e,UACHA,MACG,IAAI/N,KAAY+N,GACfA,EAAa9gB,eAAe+S,IAAe8N,IAAaA,EAAU9N,KACpE8L,EAAO9L,GAAY+N,EAAa/N,WAMjC8L,OD5D4BpX,IAAjC8B,GAAQgX,MACVhX,GAAQgX,IAAuB,GC+DjC,IAAMjT,GAAa7D,EAAWc,cAE1B+C,IAAcA,GAAW1C,SAC3B0C,GAAW1C,QAAQ6V,QCrERM,GAAoB,CAC/B,SACA,QACA,UACA,mBACA,qBACA,sBACA,UACA,iBACA,SACA,gBACA,WACA,UACA,WACA,SACA,UACA,YACA,mBACA,aACA,UACA,UACA,YACA,mBACA,mBACA,YACA,cACA,UACA,eACA,mBACA,cACA,UACA,SACA,YACA,aACA,eACA,WACA,YACA,YACA,YACA,eACA,iBACA,YACA,UACA,iBACA,gBACA,gBACA,SACA,YACA,cACA,aACA,cACA,aACA,cACA,SACA,cACA,qBACA,eACA,eACA,cACA,aACA,cACA,YACA,mBACA,WACA,gBACA,aACA,cACA,eACA,WACA,UACA,kBACA,gBACA,iBACA,iBACA,gBACA,eACA,gBACA,cACA,sBACA,wBAQWC,GAAwB,CACnC,YACA,WACA,YACA,kBACA,MACA,YACA,SACA,UACA,KACA,OACA,OACA,QACA,WACA,QACA,YACA,aACA,QAQWC,GAAwBD,GAAsBnM,OAAOkM,IAOrDG,GAAkBD,GAAsBpM,OAAO,CAC1D,SAQWsM,GAAkBF,GAAsBpM,OAAO,CAC1D,SACA,OACA,QACA,UACA,MACA,UAQWuM,GAAkBD,GAAgBtM,OAAO,CACpD,WAQWwM,GAAeJ,GAAsBpM,OAAO,CACvD,UAQWyM,GAAeL,GAA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"}